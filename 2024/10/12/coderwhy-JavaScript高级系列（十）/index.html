<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="coderwhy-JavaScript高级系列（十）" />
    <meta name="hexo-theme-A4" content="v1.8.9" />
    <link rel="alternate icon" type="image/webp" href="/images/cat.svg">
    <title>Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/images/cat.svg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Blog</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            coderwhy-JavaScript高级系列（十）
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JavaScript%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89-%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="post-toc-text">JavaScript高级系列（十） - 对象原型、原型链</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80-%E8%AE%A4%E8%AF%86%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">一. 认识原型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-%E8%AE%A4%E8%AF%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">1.1. 认识对象的原型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-%E8%AE%A4%E8%AF%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">1.2. 认识函数的原型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-1-%E5%87%BD%E6%95%B0%E7%9A%84prototype"><span class="post-toc-text">1.2.1. 函数的prototype</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98"><span class="post-toc-text">1.2.2. 创建对象的内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-3-prototype%E5%B1%9E%E6%80%A7"><span class="post-toc-text">1.2.3. prototype属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-4-constructor%E5%B1%9E%E6%80%A7"><span class="post-toc-text">1.2.4. constructor属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-5-%E9%87%8D%E5%86%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">1.2.5. 重写原型对象</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-%E7%BB%84%E5%90%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">1.3. 组合构造函数和原型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8C-%E7%B1%BB%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="post-toc-text">二. 类、原型链</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-JS%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">2.1. JS中的类和对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF"><span class="post-toc-text">2.2. 为什么需要继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="post-toc-text">2.3. JavaScript原型链</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-Object%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">2.4. Object的原型</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="JavaScript高级系列（十）-对象原型、原型链"><a href="#JavaScript高级系列（十）-对象原型、原型链" class="headerlink" title="JavaScript高级系列（十） - 对象原型、原型链"></a>JavaScript高级系列（十） - 对象原型、原型链</h1><p>原创 作者:coderwhy 公号:coderwhy 发布时间:2023-09-26 18:02 发表于广东</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0ViFDfExEMDR2cd-8sEyaQ">JavaScript高级系列（十） - 对象原型、原型链</a></p>
<blockquote>
<p>这个章节我们需要深入理解原型、原型链，这是因为JavaScript底层在实现继承的时候，使用的就是原型和原型链。</p>
<p>在学习的过程中一定要理解我课堂和文章中给出的图片，如果有必要最好自己手动来画一下。</p>
</blockquote>
<h2 id="一-认识原型"><a href="#一-认识原型" class="headerlink" title="一. 认识原型"></a>一. 认识原型</h2><h3 id="1-1-认识对象的原型"><a href="#1-1-认识对象的原型" class="headerlink" title="1.1. 认识对象的原型"></a>1.1. 认识对象的原型</h3><p>JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。</p>
<p>那么这个对象有什么用呢？</p>
<ul>
<li><p>当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作；</p>
</li>
<li><p>这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它；</p>
</li>
<li><p>如果对象中没有改属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性；</p>
</li>
<li><p>这个 [[prototype]] 我们通常会将其称之为隐式原型；</p>
</li>
</ul>
<p>那么如果通过字面量直接创建一个对象，这个对象也会有这样的属性吗？如果有，应该如何获取这个属性呢？</p>
<ul>
<li><p>答案是有的，只要是对象都会有这样的一个内置属性；</p>
</li>
<li><p>获取的方式有两种：</p>
</li>
<li><p>方式一：通过对象的 <code>__proto__</code> 属性可以获取到（但是这个是早期浏览器自己添加的，存在一定的兼容性问题）；</p>
</li>
<li><p>方式二：通过 <code>Object.getPrototypeOf</code> 方法可以获取到；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;// 方式一: __proto__(有浏览器兼容问题)</span><br><span class="line">console.log(obj.__proto__)// 方式二: Object.getPrototypeOf</span><br><span class="line">console.log(Object.getPrototypeOf(obj))</span><br></pre></td></tr></table></figure>

<p>那么我们就可以进行如下的测试了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个obj对象</span><br><span class="line">var obj = &#123;&#125;// 直接给对象添加address属性</span><br><span class="line">// obj.address = &quot;北京市&quot;// 直接给隐式原型上添加address属性</span><br><span class="line">// 给__proto__上添加address属性</span><br><span class="line">obj.__proto__.address = &quot;广州市&quot;// 通过Object.setPrototypeOf来设置隐式原型</span><br><span class="line">Object.setPrototypeOf(obj, &#123; address: &quot;上海市&quot;, name: &quot;setPrototypeOf&quot; &#125;)console.log(obj.address)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-认识函数的原型"><a href="#1-2-认识函数的原型" class="headerlink" title="1.2. 认识函数的原型"></a>1.2. 认识函数的原型</h3><h4 id="1-2-1-函数的prototype"><a href="#1-2-1-函数的prototype" class="headerlink" title="1.2.1. 函数的prototype"></a>1.2.1. 函数的prototype</h4><p>那么我们知道上面的东西对于我们的构造函数创建对象来说有什么用呢？</p>
<ul>
<li>它的意义是非常重大的，接下来我们继续来探讨；</li>
</ul>
<p>这里我们又要引入一个新的概念：所有的函数都有一个prototype的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;// 所有的函数都有一个属性, 名字是 prototype </span><br><span class="line">console.log(foo.prototype)</span><br></pre></td></tr></table></figure>

<p>你可能会问题，老师是不是因为函数是一个对象，所以它有prototype的属性呢？</p>
<ul>
<li><p>不是的，因为它是一个函数，才有了这个特殊的属性；</p>
</li>
<li><p>而不是它是一个对象，所以有这个特殊的属性；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">console.log(obj.prototype) // obj就没有这个属性</span><br></pre></td></tr></table></figure>

<p>我们前面讲过new关键字的步骤如下：</p>
<ul>
<li><p>1.在内存中创建一个新的对象（空对象）；</p>
</li>
<li><p>2.这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；（后面详细讲）；</p>
</li>
<li><p>3.构造函数内部的this，会指向创建出来的新对象；</p>
</li>
<li><p>4.执行函数的内部代码（函数体代码）；</p>
</li>
<li><p>5.如果构造函数没有返回非空对象，则返回创建出来的新对象；</p>
</li>
</ul>
<p>我们将重心放到步骤一和二中：</p>
<ul>
<li><p>在内存中创建一个对象；</p>
</li>
<li><p>将对象的[[prototype]]属性赋值为该构造函数的prototype属性；</p>
</li>
</ul>
<p>那么也就意味着：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var p1 = new Person()// 上面的操作相当于会进行如下的操作:</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.__proto__ = Person.prototype</span><br></pre></td></tr></table></figure>

<p>那么也就意味着我们通过Person构造函数创建出来的所有对象的[[prototype]]属性都指向Person.prototype：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;var p1 = new Person()</span><br><span class="line">var p2 = new Person()</span><br><span class="line">var p3 = new Person()console.log(p1.__proto__ === p2.__proto__)</span><br><span class="line">console.log(p1.__proto__ === Person.prototype)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-创建对象的内存"><a href="#1-2-2-创建对象的内存" class="headerlink" title="1.2.2. 创建对象的内存"></a>1.2.2. 创建对象的内存</h4><p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDab1IXnpAXPnnibMQZy9kApFg6yat1pLicBxXPmKmC7xEmunTnvjBc9VA/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDab1IXnpAXPnnibMQZy9kApFg6yat1pLicBxXPmKmC7xEmunTnvjBc9VA/640?wx_fmt=jpeg"></a></p>
<p>对象对象的内存表现</p>
<h4 id="1-2-3-prototype属性"><a href="#1-2-3-prototype属性" class="headerlink" title="1.2.3. prototype属性"></a>1.2.3. prototype属性</h4><p>如果我们在函数的prototype中添加属性，那么创建的对象是否可以访问到呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;Person.prototype.name = &quot;why&quot;</span><br><span class="line">Person.prototype.age = 18var p1 = new Person()</span><br><span class="line">var p2 = new Person()console.log(p1.name, p1.age)</span><br><span class="line">console.log(p2.name, p2.age)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDEaFIAicX2IlPutAps6e0LDJz2ibGic5yF3utox7ndbLLibtK16nbnpRFSA/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDEaFIAicX2IlPutAps6e0LDJz2ibGic5yF3utox7ndbLLibtK16nbnpRFSA/640?wx_fmt=jpeg"></a></p>
<p>代码的内存表现</p>
<h4 id="1-2-4-constructor属性"><a href="#1-2-4-constructor属性" class="headerlink" title="1.2.4. constructor属性"></a>1.2.4. constructor属性</h4><p>事实上原型对象上面是有一个属性的：constructor</p>
<ul>
<li>默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor) // [Function: Person]</span><br><span class="line">console.log(p1.__proto__.constructor) // [Function: Person]</span><br><span class="line">console.log(p1.__proto__.constructor.name) // Person</span><br></pre></td></tr></table></figure>

<h4 id="1-2-5-重写原型对象"><a href="#1-2-5-重写原型对象" class="headerlink" title="1.2.5. 重写原型对象"></a>1.2.5. 重写原型对象</h4><p>如果我们需要在原型上添加过多的属性，通常我们会重新整个原型对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;Person.prototype = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  eating: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们说过, 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性；</p>
<ul>
<li>而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是Person构造函数了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor) // [Function: Object]</span><br><span class="line">// 为什么是Object呢? 因为对象的字面量是由Object函数产生的</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">console.log(obj.constructor) // // [Function: Object]</span><br></pre></td></tr></table></figure>

<p>如果希望constructor指向Person，那么可以手动添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  eating: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方式虽然可以, 但是也会造成constructor的[[Enumerable]]特性被设置了true.</p>
<ul>
<li><p>默认情况下, 原生的constructor属性是不可枚举的.</p>
</li>
<li><p>如果希望解决这个问题, 就可以使用我们前面介绍的Object.defineProperty()函数了.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  eating: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-组合构造函数和原型"><a href="#1-3-组合构造函数和原型" class="headerlink" title="1.3. 组合构造函数和原型"></a>1.3. 组合构造函数和原型</h3><p>我们在上一个构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数</p>
<p>那么有没有办法让所有的对象去共享这些函数呢?</p>
<ul>
<li>可以，将这些函数放到Person.prototype的对象上即可；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, height, address) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.height = height</span><br><span class="line">  this.address = address</span><br><span class="line">&#125;Person.prototype.eating = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">&#125;Person.prototype.running = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在跑步~&quot;)</span><br><span class="line">&#125;var p1 = new Person(&quot;why&quot;, 18, 1.88, &quot;广州市&quot;)</span><br><span class="line">var p2 = new Person(&quot;kobe&quot;, 30, 1.98, &quot;北京市&quot;)p1.eating()</span><br><span class="line">p2.running()</span><br></pre></td></tr></table></figure>

<h2 id="二-类、原型链"><a href="#二-类、原型链" class="headerlink" title="二. 类、原型链"></a>二. 类、原型链</h2><h3 id="2-1-JS中的类和对象"><a href="#2-1-JS中的类和对象" class="headerlink" title="2.1. JS中的类和对象"></a>2.1. JS中的类和对象</h3><p>当我们编写如下代码的时候，我们会如何来称呼这个Person呢？</p>
<ul>
<li><p>在JS中Person应该被称之为是一个构造函数；</p>
</li>
<li><p>从很多面向对象语言过来的开发者，也习惯称之为类，因为类可以帮助我们创建出来对象p1、p2；</p>
</li>
<li><p>如果从面向对象的编程范式角度来看，Person确实是可以称之为类的；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;var p1 = new Person()</span><br><span class="line">var p2 = new Person()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-为什么需要继承"><a href="#2-2-为什么需要继承" class="headerlink" title="2.2. 为什么需要继承"></a>2.2. 为什么需要继承</h3><p>面向对象有三大特性：封装、继承、多态</p>
<ul>
<li><p>封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程；</p>
</li>
<li><p>继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中）；</p>
</li>
<li><p>多态：不同的对象在执行时表现出不同的形态；</p>
</li>
</ul>
<p>那么这里我们核心讲继承。</p>
<p>比如下面的这段代码，如果我们不使用继承，那么会存在大量的重复代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, age, sno) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.sno = sno</span><br><span class="line">&#125;Student.prototype.eating = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在吃饭~&quot;)</span><br><span class="line">&#125;Student.prototype.running = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在跑步~&quot;)</span><br><span class="line">&#125;Student.prototype.studying = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在学习~&quot;)</span><br><span class="line">&#125;function Teacher(name, age, title) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.title = title</span><br><span class="line">&#125;Teacher.prototype.eating = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在吃饭~&quot;)</span><br><span class="line">&#125;Teacher.prototype.running = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在跑步~&quot;)</span><br><span class="line">&#125;Teacher.prototype.teaching = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;上课~&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么继承是做什么呢？继承可以帮助我们将重复的代码和逻辑抽取到父类中，子类只需要直接继承过来使用即可。</p>
<p>那么JavaScript当中如何实现继承呢？</p>
<ul>
<li><p>不着急，我们先来看一下JavaScript原型链的机制；</p>
</li>
<li><p>再利用原型链的机制实现一下继承；</p>
</li>
</ul>
<h3 id="2-3-JavaScript原型链"><a href="#2-3-JavaScript原型链" class="headerlink" title="2.3. JavaScript原型链"></a>2.3. JavaScript原型链</h3><p>在真正实现继承之前，我们先来理解一个非常重要的概念：原型链。</p>
<p>我们知道，从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;obj.__proto__ = &#123;</span><br><span class="line">  address: &quot;广州市&quot;</span><br><span class="line">&#125;console.log(obj.address)</span><br></pre></td></tr></table></figure>

<p>但是如果obj的原型上也没有对应的address属性呢？必然还是获取不到的。</p>
<p>那么如果我们配置的原型对象上，继续配置原型呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;obj.__proto__ = &#123;</span><br><span class="line">&#125;obj.__proto__.__proto__ = &#123;&#125;obj.__proto__.__proto__.__proto__ = &#123;</span><br><span class="line">  address: &quot;北京市&quot;</span><br><span class="line">&#125;console.log(obj.address)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDYlhM3xBaUs4jfJeuXJH9VyoKHRhWCKL52D24zic2fDDwKtCx9Q5lL0Q/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDYlhM3xBaUs4jfJeuXJH9VyoKHRhWCKL52D24zic2fDDwKtCx9Q5lL0Q/640?wx_fmt=jpeg"></a></p>
<p>原型链</p>
<h3 id="2-4-Object的原型"><a href="#2-4-Object的原型" class="headerlink" title="2.4. Object的原型"></a>2.4. Object的原型</h3><p>那么什么地方是原型链的尽头呢？比如第三个对象是否也是有原型<code>__proto__</code>属性呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.__proto__.__proto__.__proto__.__proto__) // [Object: null prototype] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现它打印的是 <code>[Object: null prototype] &#123;&#125;</code></p>
<ul>
<li>事实上这个原型就是我们最顶层的原型了</li>
</ul>
<p>我们来研究一下默认字面量的原型是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; name: &quot;why&quot; &#125;</span><br><span class="line">console.log(obj.__proto__) // [Object: null prototype] &#123;&#125;var obj1 = new Object()</span><br><span class="line">console.log(obj1.__proto__) // [Object: null prototype] &#123;&#125;</span><br><span class="line">console.log(Object.prototype) // [Object: null prototype] &#123;&#125;console.log(obj.__proto__ === Object.prototype) // true</span><br><span class="line">console.log(obj1.__proto__ === Object.prototype) // true</span><br></pre></td></tr></table></figure>

<p>我们可以知道，从Object直接创建出来的对象的原型都是 <code>[Object: null prototype] &#123;&#125;</code>。</p>
<p>那么我们可能会问题： <code>[Object: null prototype] &#123;&#125;</code> 原型有什么特殊吗？</p>
<ul>
<li><p>特殊一：该对象不再继续有原型属性了，也就是已经是顶层原型了；</p>
</li>
<li><p>特殊二：该对象上有很多默认的属性和方法；</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDXha5N4ZW4Pl7eJib2QLM7k3tricXdWMXHRPd0ssrGdIWRItdnc6tQp0g/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDXha5N4ZW4Pl7eJib2QLM7k3tricXdWMXHRPd0ssrGdIWRItdnc6tQp0g/640?wx_fmt=jpeg"></a></p>
<p>Object原型</p>
<p>那么我们回到刚才创建的原型链中，它们最终也会找到Object的prototype的：</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDWdess3zMlwIk2ibZu5OtjRXgt74juV4JYug7DuHcaicnI1NMWDeACKyQ/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXuuXMD94cNM21Xr9FWPJ7SDDWdess3zMlwIk2ibZu5OtjRXgt74juV4JYug7DuHcaicnI1NMWDeACKyQ/640?wx_fmt=jpeg"></a></p>
<p>原型链的内存图</p>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-10-12</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>宇宙里有什么不是暂时</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


    <!--暗黑模式-->
    <script src="/js/darkmode-js.min.js"></script>
    <script>
        function addDarkmodeWidget() {
        const options = {
            bottom: '53px', // default: '32px'
            right: 'unset', // default: '32px'
            left: '42px', // default: 'unset'
            time: '0.3s', // default: '0.3s'
            mixColor: '#fff', // default: '#fff'
            backgroundColor: ' #e4e4e4 ',  // default: '#fff'
            buttonColorDark: '#100f2c',  // default: '#100f2c'
            buttonColorLight: '#fff', // default: '#fff'
            saveInCookies: true, // default: true,
            label: '🌓', // default: ''
            autoMatchOsTheme: true // default: true
        }
    
        const darkmode = new Darkmode(options);
        darkmode.showWidget();
        
        }
        window.addEventListener('load', addDarkmodeWidget);
    </script>
  
</html>