<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="coderwhy-JavaScript高级系列（三）" />
    <meta name="hexo-theme-A4" content="v1.8.9" />
    <link rel="alternate icon" type="image/webp" href="/images/cat.svg">
    <title>Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/images/cat.svg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Blog</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            coderwhy-JavaScript高级系列（三）
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JavaScript%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89-JavaScript%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="post-toc-text">JavaScript高级系列（三） - JavaScript的运行过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="post-toc-text">一. 全局代码的执行过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-ECMA%E7%9A%84%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="post-toc-text">1.1. ECMA的版本说明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-text">1.2. 全局代码初始化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">1.2.1. 初始化全局对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88EC%EF%BC%89"><span class="post-toc-text">1.2.2. 执行上下文（EC）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="post-toc-text">1.3. 全局代码的执行</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-1-VO%E5%92%8CGO%E7%9A%84%E7%90%86%E8%A7%A3"><span class="post-toc-text">1.3.1. VO和GO的理解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-2-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E6%89%A7%E8%A1%8C%E5%89%8D%EF%BC%89"><span class="post-toc-text">1.3.2. 全局代码执行过程（执行前）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-3-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%89"><span class="post-toc-text">1.3.3. 全局代码执行过程（执行后）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8C-%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="post-toc-text">二. 函数代码的执行过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="post-toc-text">2.1. 函数代码的执行过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-1-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5%E6%8F%8F%E8%BF%B0"><span class="post-toc-text">2.1.1. 函数执行的概念描述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-2-%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E6%89%A7%E8%A1%8C%E5%89%8D%EF%BC%89"><span class="post-toc-text">2.1.2. 函数代码执行过程（执行前）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-3-%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%89"><span class="post-toc-text">2.1.3. 函数代码执行过程（执行后）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="post-toc-text">2.2. 作用域、作用域链</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="post-toc-text">2.2.1. 作用域、作用域链的理解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2-%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="post-toc-text">2.2.2. 作用域、作用域链面试题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-%E9%97%AD%E5%8C%85%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="post-toc-text">2.3. 闭包和闭包的内存泄漏</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-1-%E9%97%AD%E5%8C%85%E7%9A%84%E8%BF%B7%E6%83%91%E4%B9%8B%E5%A4%84"><span class="post-toc-text">2.3.1. 闭包的迷惑之处</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-2-%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="post-toc-text">2.3.2. 闭包的概念定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-3-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BD%A2%E6%88%90%E8%BF%87%E7%A8%8B"><span class="post-toc-text">2.3.3. 闭包的形成过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-4-%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="post-toc-text">2.3.4. 闭包的内存泄漏</span></a></li></ol></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="JavaScript高级系列（三）-JavaScript的运行过程"><a href="#JavaScript高级系列（三）-JavaScript的运行过程" class="headerlink" title="JavaScript高级系列（三） - JavaScript的运行过程"></a>JavaScript高级系列（三） - JavaScript的运行过程</h1><p>原创 作者:coderwhy 公号:coderwhy 发布时间:2023-09-10 18:00 发表于广东</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uw170KUZECH0TDVJ06bJxw">JavaScript高级系列（三） - JavaScript的运行过程</a></p>
<blockquote>
<p>本节内容会先讲解JavaScript的执行过程，再来学习作用域、作用域链等核心概念。</p>
<p>当理解了这些内容后，就可以很好的理解闭包、闭包的内存泄漏等。</p>
</blockquote>
<h2 id="一-全局代码的执行过程"><a href="#一-全局代码的执行过程" class="headerlink" title="一. 全局代码的执行过程"></a>一. 全局代码的执行过程</h2><h3 id="1-1-ECMA的版本说明"><a href="#1-1-ECMA的版本说明" class="headerlink" title="1.1. ECMA的版本说明"></a>1.1. ECMA的版本说明</h3><p>在ECMA早期的版本中（ECMAScript3），代码的执行流程的术语和ECMAScript5以及之后的术语会有所区别：</p>
<ul>
<li><p>目前网上大多数流行的说法都是基于ECMAScript3版本的解析，并且在面试时问到的大多数都是ECMAScript3的版本内容；</p>
</li>
<li><p>但是ECMAScript3终将过去， ECMAScript5必然会成为主流，所以最好也理解ECMAScript5甚至包括ECMAScript6以及更好版本的内容；</p>
</li>
<li><p>事实上在TC39（ ECMAScript5 ）的最新描述中，和ECMAScript5之后的版本又出现了一定的差异；</p>
</li>
</ul>
<p><strong>那么我们课程按照如下顺序学习：</strong></p>
<ul>
<li><p>通过ECMAScript3中的概念学习JavaScript执行原理、作用域、作用域链、闭包等概念；</p>
</li>
<li><p>通过ECMAScript5中的概念学习块级作用域、let、const等概念；</p>
</li>
</ul>
<p><strong>事实上，它们只是在对某些概念上的描述不太一样，在整体思路上都是一致的。</strong></p>
<h3 id="1-2-全局代码初始化"><a href="#1-2-全局代码初始化" class="headerlink" title="1.2. 全局代码初始化"></a>1.2. 全局代码初始化</h3><p>假如我们有下面一段代码，它在JavaScript中是如何被执行的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;why&quot;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var name = &quot;foo&quot;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;var num1 = 20</span><br><span class="line">var num2 = 30</span><br><span class="line">var result = num1 + num2foo()</span><br></pre></td></tr></table></figure>

<h4 id="1-2-1-初始化全局对象"><a href="#1-2-1-初始化全局对象" class="headerlink" title="1.2.1. 初始化全局对象"></a>1.2.1. 初始化全局对象</h4><p>js引擎会在执行代码之前，会在堆内存中创建一个全局对象：</p>
<ul>
<li><p>Global Object（GO） 该对象 所有的作用域（scope）都可以访问；</p>
</li>
<li><p>里面会包含Date、Array、String、Number、setTimeout、setInterval等等；</p>
</li>
<li><p>其中还有一个window属性指向自己；</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmD0IGfVlNBaVzAYOMNSuYDO1dWrGjU00qRmhJRXjEEibqAuickZ5Ikp3gw/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmD0IGfVlNBaVzAYOMNSuYDO1dWrGjU00qRmhJRXjEEibqAuickZ5Ikp3gw/640?wx_fmt=png"></a></p>
<p>全局对象</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDroqq3Eibyg2YrUcEuHwAvzypOib0a7PNRxSKoHqy5CCQtnicIVHujBnLQ/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDroqq3Eibyg2YrUcEuHwAvzypOib0a7PNRxSKoHqy5CCQtnicIVHujBnLQ/640?wx_fmt=png"></a></p>
<p>内存中创建一个全局对象</p>
<h4 id="1-2-2-执行上下文（EC）"><a href="#1-2-2-执行上下文（EC）" class="headerlink" title="1.2.2. 执行上下文（EC）"></a>1.2.2. 执行上下文（EC）</h4><p>在 JavaScript 引擎内部，有一个执行上下文栈（Execution Context Stack，简称 ECS），它是用于执行代码的调用栈，存储着当前正在执行的执行上下文。</p>
<p>当 JavaScript 引擎开始执行代码时，它会先创建一个全局执行上下文（Global Execution Context，简称 GEC），并将其推入 ECS 中，表示当前正在执行全局的代码块。</p>
<p>GEC 包含了两部分内容：</p>
<ul>
<li><p>第一部分是在代码执行前，JavaScript 引擎会扫描全局作用域下的变量和函数，将它们添加到全局对象（Global Object）中，并分配内存空间，但是并不会赋值。这个过程称为变量的作用域提升（hoisting）。</p>
</li>
<li><p>第二部分是在代码执行中，JavaScript 引擎会对变量进行赋值，并执行其他的函数。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDso3vDfgyuibTWXC0oFrNWwaBa7ojg8WVmZJNMuFpib2xJRa19d9EibPrQ/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDso3vDfgyuibTWXC0oFrNWwaBa7ojg8WVmZJNMuFpib2xJRa19d9EibPrQ/640?wx_fmt=png"></a></p>
<p>执行上下文</p>
<h3 id="1-3-全局代码的执行"><a href="#1-3-全局代码的执行" class="headerlink" title="1.3. 全局代码的执行"></a>1.3. 全局代码的执行</h3><h4 id="1-3-1-VO和GO的理解"><a href="#1-3-1-VO和GO的理解" class="headerlink" title="1.3.1. VO和GO的理解"></a>1.3.1. VO和GO的理解</h4><p>每一个执行上下文会关联一个VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中。</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDlqwX4OgM11OYic6Wv9ic5HWTiajZIZuu0BUMV5nHV735J0O7Vz8CEYQlA/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDlqwX4OgM11OYic6Wv9ic5HWTiajZIZuu0BUMV5nHV735J0O7Vz8CEYQlA/640?wx_fmt=png"></a></p>
<p>VO的描述</p>
<p>变量对象是一个抽象的概念，在 JavaScript 引擎内部，它被实现为一个与当前执行上下文相关联的对象。</p>
<ul>
<li><p>在全局执行上下文中，变量对象是全局对象（Global Object）；</p>
</li>
<li><p>在函数执行上下文中，变量对象是一个称为活动对象（Activation Object）的对象。</p>
</li>
</ul>
<p>当全局代码被执行的时候，VO就是GO对象了</p>
<ul>
<li><p>当全局代码被执行时，变量对象（Variable Object，简称 VO）就是全局对象（Global Object，简称 GO）了。</p>
</li>
<li><p>全局对象是在 JavaScript 引擎内部创建的一个唯一对象，它在全局作用域下被访问，并且可以存储全局变量、函数、内置对象和浏览器提供的 API 等等。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDsbZN2cAED0kGOWLD2VecJPuLWjuLbsJg8f2KbSDYDzQ54hAzLFyn0g/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDsbZN2cAED0kGOWLD2VecJPuLWjuLbsJg8f2KbSDYDzQ54hAzLFyn0g/640?wx_fmt=png"></a></p>
<p>全局代码执行</p>
<h4 id="1-3-2-全局代码执行过程（执行前）"><a href="#1-3-2-全局代码执行过程（执行前）" class="headerlink" title="1.3.2. 全局代码执行过程（执行前）"></a>1.3.2. 全局代码执行过程（执行前）</h4><p>GO 对象在执行全局代码之前就已经被创建，并且包含了一些内置对象和方法，例如 Object、Array、String、Number、Math、JSON、setTimeout、setInterval 等等。</p>
<p>当全局执行上下文被创建时，变量对象 VO 会被设置为 GO 对象，并且全局作用域下的变量和函数会被添加到变量对象中。</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDNZbALdkrqweQ9dPGInSH56PibQSSyHeia9yqyFLniaDtYOBywEBIQSLJQ/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDNZbALdkrqweQ9dPGInSH56PibQSSyHeia9yqyFLniaDtYOBywEBIQSLJQ/640?wx_fmt=png"></a></p>
<p>全局代码执行前</p>
<h4 id="1-3-3-全局代码执行过程（执行后）"><a href="#1-3-3-全局代码执行过程（执行后）" class="headerlink" title="1.3.3. 全局代码执行过程（执行后）"></a>1.3.3. 全局代码执行过程（执行后）</h4><p>代码执行后就会给变量进行复制操作：</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDYsXQfhdzJbplic8VCuHibU9gVj1KI7ib6iaQgRlzuhgmAr9tEQ0HpSoEsA/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDYsXQfhdzJbplic8VCuHibU9gVj1KI7ib6iaQgRlzuhgmAr9tEQ0HpSoEsA/640?wx_fmt=png"></a></p>
<p>全局代码执行后</p>
<h2 id="二-函数代码的执行过程"><a href="#二-函数代码的执行过程" class="headerlink" title="二. 函数代码的执行过程"></a>二. 函数代码的执行过程</h2><h3 id="2-1-函数代码的执行过程"><a href="#2-1-函数代码的执行过程" class="headerlink" title="2.1. 函数代码的执行过程"></a>2.1. 函数代码的执行过程</h3><h4 id="2-1-1-函数执行的概念描述"><a href="#2-1-1-函数执行的概念描述" class="headerlink" title="2.1.1. 函数执行的概念描述"></a>2.1.1. 函数执行的概念描述</h4><p>在 JavaScript 中，当函数被调用时，会创建一个函数执行上下文（Functional Execution Context，简称 FEC），并将其压入执行上下文栈（Execution Context Stack，简称 ECS）中，表示当前正在执行该函数的代码块。</p>
<p>函数执行上下文关联的变量对象（Variable Object，简称 VO）是一个称为活动对象（Activation Object，简称 AO）的对象。</p>
<ul>
<li><p>在进入函数执行上下文时，JavaScript 引擎会创建一个 AO 对象，并将其关联到当前的执行上下文中。</p>
</li>
<li><p>AO 对象是一个包含函数的参数、函数声明和变量声明的列表。</p>
</li>
<li><p>它的初始值使用函数的参数列表作为参数并进行初始化。</p>
</li>
<li><p>这个 AO 对象会作为执行上下文的变量对象（VO）来存储变量的初始化。</p>
</li>
</ul>
<p>当函数执行完毕后，其执行上下文会从 ECS 中弹出，AO 对象会被垃圾回收，所以不能在函数执行完毕后再访问该函数的 AO 对象。</p>
<h4 id="2-1-2-函数代码执行过程（执行前）"><a href="#2-1-2-函数代码执行过程（执行前）" class="headerlink" title="2.1.2. 函数代码执行过程（执行前）"></a>2.1.2. 函数代码执行过程（执行前）</h4><p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDKhMTBT3WvpaQibO5ZqbUcK68SuibUxxRyUL3g6mnnHgWfjOxib8T81COw/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDKhMTBT3WvpaQibO5ZqbUcK68SuibUxxRyUL3g6mnnHgWfjOxib8T81COw/640?wx_fmt=png"></a></p>
<p>函数代码执行前</p>
<h4 id="2-1-3-函数代码执行过程（执行后）"><a href="#2-1-3-函数代码执行过程（执行后）" class="headerlink" title="2.1.3. 函数代码执行过程（执行后）"></a>2.1.3. 函数代码执行过程（执行后）</h4><p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDjKdhhyjjX3JVHPCvNjjXkRQPAh5z0BhujWl9AibddsUZKwQHmAo49OA/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDjKdhhyjjX3JVHPCvNjjXkRQPAh5z0BhujWl9AibddsUZKwQHmAo49OA/640?wx_fmt=png"></a></p>
<p>函数代码执行后</p>
<h3 id="2-2-作用域、作用域链"><a href="#2-2-作用域、作用域链" class="headerlink" title="2.2. 作用域、作用域链"></a>2.2. 作用域、作用域链</h3><h4 id="2-2-1-作用域、作用域链的理解"><a href="#2-2-1-作用域、作用域链的理解" class="headerlink" title="2.2.1. 作用域、作用域链的理解"></a>2.2.1. 作用域、作用域链的理解</h4><p>在 JavaScript 中，当进入一个执行上下文时，执行上下文也会关联一个作用域链（Scope Chain）。</p>
<ul>
<li><p>作用域链是一个对象列表，用于变量标识符的查找和求值。</p>
</li>
<li><p>当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象；</p>
</li>
</ul>
<p>作用域链是由当前执行上下文的变量对象（VO）和所有外部环境的作用域链组成的。</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDiayj0Zn1aIY9RWSCtsaEicQL130uTCwpg8SfuzXZVdfG8q8fXDzZeVxg/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDiayj0Zn1aIY9RWSCtsaEicQL130uTCwpg8SfuzXZVdfG8q8fXDzZeVxg/640?wx_fmt=png"></a></p>
<p>作用域链的描述</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmD3Sice4ENQTWXhjRia3Q5icAdBe4IVOaxicxYjAcPOmic96OgUlf9uvFuDSg/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmD3Sice4ENQTWXhjRia3Q5icAdBe4IVOaxicxYjAcPOmic96OgUlf9uvFuDSg/640?wx_fmt=png"></a></p>
<p>作用域链</p>
<p>具体内容可以查看视频中的讲解过程。</p>
<h4 id="2-2-2-作用域、作用域链面试题"><a href="#2-2-2-作用域、作用域链面试题" class="headerlink" title="2.2.2. 作用域、作用域链面试题"></a>2.2.2. 作用域、作用域链面试题</h4><p>接下来我们可以利用变量的提升过程，做一些面试题：</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDS4VD4andvOBuria7avIsknTmW8egKvsNS9XhooAw3rmb4Kr9NUYbPfQ/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDS4VD4andvOBuria7avIsknTmW8egKvsNS9XhooAw3rmb4Kr9NUYbPfQ/640?wx_fmt=png"></a></p>
<p>作用域提升的面试题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 1.面试题一:</span><br><span class="line">var n = 100</span><br><span class="line">function foo() &#123;</span><br><span class="line">  n = 200</span><br><span class="line">&#125;</span><br><span class="line">foo()console.log(n)// 2.面试题二:</span><br><span class="line">var n = 100</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">  var n = 200</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;foo()// 3.面试题三:</span><br><span class="line">var n = 100function foo1() &#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">function foo2() &#123;</span><br><span class="line">  var n = 200</span><br><span class="line">  console.log(n)</span><br><span class="line">  foo1()</span><br><span class="line">&#125;</span><br><span class="line">foo2()// 4.面试题四:</span><br><span class="line">var n = 100</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">  return</span><br><span class="line">  var n = 200</span><br><span class="line">  &#125;</span><br><span class="line">foo()// 5.在开发中可能会出现这样错误的写法</span><br><span class="line">function foo() &#123;</span><br><span class="line">  message = &quot;Hello World&quot;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(message)// 6.面试题五:</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var a = b = 100</span><br><span class="line">  &#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-闭包和闭包的内存泄漏"><a href="#2-3-闭包和闭包的内存泄漏" class="headerlink" title="2.3. 闭包和闭包的内存泄漏"></a>2.3. 闭包和闭包的内存泄漏</h3><h4 id="2-3-1-闭包的迷惑之处"><a href="#2-3-1-闭包的迷惑之处" class="headerlink" title="2.3.1. 闭包的迷惑之处"></a>2.3.1. 闭包的迷惑之处</h4><p>闭包是JavaScript中一个非常容易让人迷惑的知识点：</p>
<ul>
<li><p>有同学在深入JS高级的交流群中发了这么一张图片（这张图来自你不知道的JavaScript）；</p>
</li>
<li><p>并且闭包也是群里面大家讨论最多的一个话题；</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDfYAXsBGCwnh7dsMe2MDvKmveuJiauhiaWdqyCzkC55SlFuzotU2FPlMw/640?wx_fmt=png" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXut4lpNWJnsicqicdcjsKFxkmDfYAXsBGCwnh7dsMe2MDvKmveuJiauhiaWdqyCzkC55SlFuzotU2FPlMw/640?wx_fmt=png"></a></p>
<p>你不知道的JavaScript</p>
<p>闭包确实是JavaScript中一个很难理解的知识点，接下来我们就对其一步步来进行剖析，看看它到底有什么神奇之处。</p>
<h4 id="2-3-2-闭包的概念定义"><a href="#2-3-2-闭包的概念定义" class="headerlink" title="2.3.2. 闭包的概念定义"></a>2.3.2. 闭包的概念定义</h4><p>这里先来看一下闭包的定义，分成两个：在计算机科学中和在JavaScript中。</p>
<p>在计算机科学中对闭包的定义（维基百科）：</p>
<ul>
<li><p>闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures）；</p>
</li>
<li><p>是在支持 头等函数 的编程语言中，实现词法绑定的一种技术；</p>
</li>
<li><p>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；</p>
</li>
<li><p>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 自由变量 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；</p>
</li>
</ul>
<p>闭包的概念出现于60年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么JavaScript中有闭包：</p>
<ul>
<li>因为JavaScript中有大量的设计是来源于Scheme的；</li>
</ul>
<p>我们再来看一下MDN对JavaScript闭包的解释：</p>
<ul>
<li><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；</p>
</li>
<li><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</p>
</li>
<li><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</p>
</li>
</ul>
<p>那么我的理解和总结：</p>
<ul>
<li><p>一个普通的函数function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；</p>
</li>
<li><p>从广义的角度来说：JavaScript中的函数都是闭包；</p>
</li>
<li><p>从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；</p>
</li>
</ul>
<h4 id="2-3-3-闭包的形成过程"><a href="#2-3-3-闭包的形成过程" class="headerlink" title="2.3.3. 闭包的形成过程"></a>2.3.3. 闭包的形成过程</h4><p>当我们的代码没有闭包时，往往代码会有非常大的局限性：</p>
<ul>
<li>如果一个函数需要使用到外面作用域的变量，那么必须将所有的变量全部传入进去。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;why&quot;</span><br><span class="line">var age = 18</span><br><span class="line">var height = 1.88</span><br><span class="line">var address = &quot;广州市&quot;</span><br><span class="line">var intro = &quot;了解真相, 你才能获得真正自由!&quot;function foo(name, age, height, address, intro, num1, num2) &#123;</span><br><span class="line">  var message = &quot;Hello World&quot;</span><br><span class="line">  console.log(message, name, age, height, address, intro)  function bar() &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">  &#125;  bar()</span><br><span class="line">&#125;foo(name, age, height, address, intro, 20, 30)</span><br></pre></td></tr></table></figure>

<p>有了闭包之后，我们可以进行如下代码的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createAdder(count) &#123;</span><br><span class="line">  function adder(num) &#123;</span><br><span class="line">    return count + num</span><br><span class="line">  &#125;  return adder</span><br><span class="line">&#125;var adder5 = createAdder(5)</span><br><span class="line">adder5(100)</span><br><span class="line">adder5(55)</span><br><span class="line">adder5(12)var adder8 = createAdder(8)</span><br><span class="line">adder8(22)</span><br><span class="line">adder8(35)</span><br><span class="line">adder8(7)console.log(adder5(24))</span><br><span class="line">console.log(adder8(30))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-闭包的内存泄漏"><a href="#2-3-4-闭包的内存泄漏" class="headerlink" title="2.3.4. 闭包的内存泄漏"></a>2.3.4. 闭包的内存泄漏</h4><p>使用闭包可能会导致内存泄漏：</p>
<ul>
<li><p>因为闭包会引用外部函数的变量对象，如果这个闭包被长期保存，那么外部函数的变量对象就会一直存在内存中，无法被垃圾回收。</p>
</li>
<li><p>因此，在使用闭包时，需要注意内存的管理。</p>
</li>
</ul>
<p>那么我们为什么经常会说闭包是有内存泄露的呢？</p>
<ul>
<li><p>在上面的案例中，如果后续我们不再使用add10函数了，那么该函数对象应该要被销毁掉，并且其引用着的父作用域AO也应该被销毁掉；</p>
</li>
<li><p>但是目前因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作用域中AO（0x200）有引用，所以最终会造成这些内存都是无法被释放的；</p>
</li>
<li><p>所以我们经常说的闭包会造成内存泄露，其实就是刚才的引用链中的所有对象都是无法释放的；</p>
</li>
</ul>
<p>那么，怎么解决这个问题呢？</p>
<ul>
<li><p>因为当将add8设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了；</p>
</li>
<li><p>在GC的下一次检测中，它们就会被销毁掉；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createAdder(count) &#123;</span><br><span class="line">  function adder(num) &#123;</span><br><span class="line">    return count + num</span><br><span class="line">  &#125;  return adder</span><br><span class="line">&#125;var adder5 = createAdder(5)</span><br><span class="line">adder5(100)</span><br><span class="line">adder5(55)</span><br><span class="line">adder5(12)var adder8 = createAdder(8)</span><br><span class="line">adder8(22)</span><br><span class="line">adder8(35)</span><br><span class="line">adder8(7)console.log(adder5(24))</span><br><span class="line">console.log(adder8(30))// 永远不会再使用adder8</span><br><span class="line">// 内存泄漏: 对于那些我们永远不会再使用的对象, 但是对于GC来说, 它不知道要进行释放的对应内存会依然保留着</span><br><span class="line">adder8 = null</span><br></pre></td></tr></table></figure></div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-10-12</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>宇宙里有什么不是暂时</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


    <!--暗黑模式-->
    <script src="/js/darkmode-js.min.js"></script>
    <script>
        function addDarkmodeWidget() {
        const options = {
            bottom: '53px', // default: '32px'
            right: 'unset', // default: '32px'
            left: '42px', // default: 'unset'
            time: '0.3s', // default: '0.3s'
            mixColor: '#fff', // default: '#fff'
            backgroundColor: ' #e4e4e4 ',  // default: '#fff'
            buttonColorDark: '#100f2c',  // default: '#100f2c'
            buttonColorLight: '#fff', // default: '#fff'
            saveInCookies: true, // default: true,
            label: '🌓', // default: ''
            autoMatchOsTheme: true // default: true
        }
    
        const darkmode = new Darkmode(options);
        darkmode.showWidget();
        
        }
        window.addEventListener('load', addDarkmodeWidget);
    </script>
  
</html>