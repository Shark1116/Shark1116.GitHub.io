<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="coderwhy-JavaScript高级系列（九）" />
    <meta name="hexo-theme-A4" content="v1.8.9" />
    <link rel="alternate icon" type="image/webp" href="/images/cat.svg">
    <title>Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/images/cat.svg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Blog</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            coderwhy-JavaScript高级系列（九）
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JavaScript%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">JavaScript高级系列（九） - 理解对象和创建对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80-%E8%AE%A4%E8%AF%86JavaScript%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">一. 认识JavaScript对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="post-toc-text">1.1. 对象的定义方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">1.2. 如何创建对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0"><span class="post-toc-text">1.3. 对象的属性描述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-1-%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="post-toc-text">1.3.1. 数据属性描述符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-2-%E5%AD%98%E5%8F%96%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="post-toc-text">1.3.2. 存取属性描述符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-3-%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="post-toc-text">1.3.3. 同时定义多个属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-4-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%A5%E5%85%85"><span class="post-toc-text">1.3.4. 对象方法的补充</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">二. 创建对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">2.1. 如何创建多个对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">2.2. 工厂模式创建对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">2.3. 构造函数创建对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-1-%E8%AE%A4%E8%AF%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-text">2.3.1. 认识构造函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-2-new-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="post-toc-text">2.3.2. new 操作符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="post-toc-text">2.3.4. 构造函数方式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%89-%E8%AE%A4%E8%AF%86%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">三. 认识原型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-%E8%AE%A4%E8%AF%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">3.1. 认识对象的原型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-%E8%AE%A4%E8%AF%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">3.2. 认识函数的原型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-1-%E5%87%BD%E6%95%B0%E7%9A%84prototype"><span class="post-toc-text">3.2.1. 函数的prototype</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98"><span class="post-toc-text">3.2.2. 创建对象的内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-3-prototype%E5%B1%9E%E6%80%A7"><span class="post-toc-text">3.2.3. prototype属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-4-constructor%E5%B1%9E%E6%80%A7"><span class="post-toc-text">3.2.4. constructor属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-5-%E9%87%8D%E5%86%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">3.2.5. 重写原型对象</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-%E7%BB%84%E5%90%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B"><span class="post-toc-text">3.3. 组合构造函数和原型</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="JavaScript高级系列（九）-理解对象和创建对象"><a href="#JavaScript高级系列（九）-理解对象和创建对象" class="headerlink" title="JavaScript高级系列（九） - 理解对象和创建对象"></a>JavaScript高级系列（九） - 理解对象和创建对象</h1><p>原创 作者:coderwhy 公号:coderwhy 发布时间:2023-09-25 23:06 发表于广东</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-SjZjv2_5F6ZPcWYSdTevg">JavaScript高级系列（九） - 理解对象和创建对象</a></p>
<blockquote>
<p>从这个章节开始，我们会开始学习JavaScript的面向对象相关的知识。</p>
<p>本章节只是让大家更好的理解对象以及如果我们想要批量创建多个对象时，应该如何进行操作。</p>
</blockquote>
<h2 id="一-认识JavaScript对象"><a href="#一-认识JavaScript对象" class="headerlink" title="一. 认识JavaScript对象"></a>一. 认识JavaScript对象</h2><h3 id="1-1-对象的定义方式"><a href="#1-1-对象的定义方式" class="headerlink" title="1.1. 对象的定义方式"></a>1.1. 对象的定义方式</h3><p>对象是JavaScript中一个非常重要的概念，这是因为对象可以将多个相关联的数据封装到一起，更好的描述一个事物：</p>
<ul>
<li><p>比如我们可以描述一辆车：Car，具有颜色（color）、速度（speed）、品牌（brand）、价格（price），行驶（travel）等等；</p>
</li>
<li><p>比如我们可以描述一个人：Person，具有姓名（name）、年龄（age）、身高（height），吃东西（eat）、跑步（run）等等；</p>
</li>
</ul>
<p>用对象来描述事物，更有利于我们将现实的事物，抽离成代码中某个数据结构：</p>
<ul>
<li><p>所以有一些编程语言就是纯面向对象的编程语言，比Java；</p>
</li>
<li><p>你在实现任何现实抽象时都需要先创建一个类，根据类再去创建对象；</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXus1NwNcQzEZbOic8je5EuXcAcBBn9VgkNIiarOYfg7EbyppwN8I9CsZgtWYxWpuiaoPfpSKpuhMKP6NA/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXus1NwNcQzEZbOic8je5EuXcAcBBn9VgkNIiarOYfg7EbyppwN8I9CsZgtWYxWpuiaoPfpSKpuhMKP6NA/640?wx_fmt=jpeg"></a></p>
<p>现实到编程的抽象</p>
<p>JavaScript其实支持多种编程范式的，包括函数式编程和面向对象编程：</p>
<ul>
<li><p>JavaScript中的对象被设计成一组属性的无序集合，像是一个哈希表，有key和value组成；</p>
</li>
<li><p>key是一个标识符，value可以是任意类型，包括也可以是其他对象或者函数类型；</p>
</li>
<li><p>如果值是一个函数，那么我们可以称之为是对象的方法；</p>
</li>
</ul>
<h3 id="1-2-如何创建对象"><a href="#1-2-如何创建对象" class="headerlink" title="1.2. 如何创建对象"></a>1.2. 如何创建对象</h3><p>早期使用创建对象的方式最多的是使用Object类，并且使用new关键字来创建一个对象：</p>
<ul>
<li>这是因为早期很多JavaScript开发者是从Java过来的，它们也更习惯于Java中通过new的方式创建一个对象；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建一个空的对象</span><br><span class="line">var obj1 = new Object()</span><br><span class="line">obj1.name = &quot;why&quot;</span><br><span class="line">obj1.age = 18</span><br><span class="line">obj1.height = 1.88</span><br><span class="line">obj1.eating = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在吃东西&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来很多开发者为了方便期间，都是直接通过字面量的形式来创建对象：</p>
<ul>
<li>这种形式看起来更加的简洁，并且对象和属性之间的内聚性也更强，所以这种方式后来就流行了起来；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 2.字面量的形式创建对象</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  name: &quot;kobe&quot;,</span><br><span class="line">  age: 40,</span><br><span class="line">  height: 1.98,</span><br><span class="line">  running: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在跑步&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-对象的属性描述"><a href="#1-3-对象的属性描述" class="headerlink" title="1.3. 对象的属性描述"></a>1.3. 对象的属性描述</h3><p>在前面我们的属性都是直接定义在对象内部，或者直接添加到对象内部的：</p>
<ul>
<li>但是这样来做的时候我们就不能对这个属性进行一些限制：比如这个属性是否是可以通过delete删除的？这个属性是否在for-in遍历的时候被遍历出来呢？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &quot;why&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用使用属性描述符。</p>
<ul>
<li><p>通过属性描述符可以精准的添加或修改对象的属性；</p>
</li>
<li><p>属性描述符需要使用 <code>Object.defineProperty</code> 来对属性进行添加或者修改；</p>
</li>
</ul>
<p>属性描述符的类型有两种：</p>
<ul>
<li><p>数据属性（Data Properties）描述符（Descriptor）；</p>
</li>
<li><p>存取属性（Accessor访问器 Properties）描述符（Descriptor）；</p>
</li>
</ul>
<h4 id="1-3-1-数据属性描述符"><a href="#1-3-1-数据属性描述符" class="headerlink" title="1.3.1. 数据属性描述符"></a>1.3.1. 数据属性描述符</h4><p>数据数据描述符有如下四个特性：</p>
<ul>
<li><p>[[Configurable]]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；</p>
</li>
<li><p>当我们直接在一个对象上定义某个属性时，这个属性的[[Configurable]]为true；</p>
</li>
<li><p>当我们通过属性描述符定义一个属性时，这个属性的[[Configurable]]默认为false；</p>
</li>
<li><p>[[Enumerable]]：表示属性是否可以通过for-in或者Object.keys()返回该属性；</p>
</li>
<li><p>当我们直接在一个对象上定义某个属性时，这个属性的[[Enumerable]]为true；</p>
</li>
<li><p>当我们通过属性描述符定义一个属性时，这个属性的[[Enumerable]]默认为false；</p>
</li>
<li><p>[[Writable]]：表示是否可以修改属性的值；</p>
</li>
<li><p>当我们直接在一个对象上定义某个属性时，这个属性的[[Writable]]为true；</p>
</li>
<li><p>当我们通过属性描述符定义一个属性时，这个属性的[[Writable]]默认为false；</p>
</li>
<li><p>[[value]]：属性的value值，读取属性时会返回该值，修改属性时，会对其进行修改；</p>
</li>
<li><p>默认情况下这个值是undefined；</p>
</li>
</ul>
<p>接下来我们来测试一下默认添加的属性，上面的特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  height: 1.88</span><br><span class="line">&#125;// 默认是可以配置</span><br><span class="line">// delete obj.name</span><br><span class="line">// console.log(obj)for (var key in obj) &#123;</span><br><span class="line">  console.log(key)</span><br><span class="line">&#125;console.log(Object.keys(obj))obj.name = &quot;kobe&quot;</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>

<p>自己定义某一个属性，来查看它们的特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// &quot;use strict&quot;var obj = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  height: 1.88</span><br><span class="line">&#125;// 自己定义的属性</span><br><span class="line">Object.defineProperty(obj, &quot;address&quot;, &#123;</span><br><span class="line">  // configurable: false,</span><br><span class="line">  // enumerable: false,</span><br><span class="line">  // writable: false,</span><br><span class="line">  value: &quot;北京市&quot;</span><br><span class="line">&#125;)// 1.测试enumerable为false</span><br><span class="line">// 这种方式访问时看不到属性</span><br><span class="line">console.log(obj)</span><br><span class="line">console.log(Object.keys(obj))</span><br><span class="line">for (var key in obj) &#123;</span><br><span class="line">  console.log(key)</span><br><span class="line">&#125;</span><br><span class="line">// 这种方式是可以访问的</span><br><span class="line">console.log(&quot;address&quot; in obj)</span><br><span class="line">console.log(obj.hasOwnProperty(&#x27;address&#x27;))</span><br><span class="line">console.log(obj.address)// 2.测试writable, 修改address的值</span><br><span class="line">obj.address = &quot;广州市&quot;</span><br><span class="line">// 北京市, 并且在严格模式下会报错</span><br><span class="line">console.log(obj.address)// 3.测试configurable</span><br><span class="line">// 不可以删除</span><br><span class="line">delete obj.address</span><br><span class="line">// 不可以重新修改</span><br><span class="line">Object.defineProperty(obj, &#x27;address&#x27;, &#123;</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;)console.log(obj.address)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-存取属性描述符"><a href="#1-3-2-存取属性描述符" class="headerlink" title="1.3.2. 存取属性描述符"></a>1.3.2. 存取属性描述符</h4><p>数据数据描述符有如下四个特性：</p>
<ul>
<li><p>[[Configurable]]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；</p>
</li>
<li><p>和数据属性描述符是一致的；</p>
</li>
<li><p>当我们直接在一个对象上定义某个属性时，这个属性的[[Configurable]]为true；</p>
</li>
<li><p>当我们通过属性描述符定义一个属性时，这个属性的[[Configurable]]默认为false；</p>
</li>
<li><p>[[Enumerable]]：表示属性是否可以通过for-in或者Object.keys()返回该属性；</p>
</li>
<li><p>和数据属性描述符是一致的；</p>
</li>
<li><p>当我们直接在一个对象上定义某个属性时，这个属性的[[Enumerable]]为true；</p>
</li>
<li><p>当我们通过属性描述符定义一个属性时，这个属性的[[Enumerable]]默认为false；</p>
</li>
<li><p>[[get]]：获取属性时会执行的函数。默认为undefined</p>
</li>
<li><p>[[set]]：设置属性时会执行的函数。默认为undefined</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;var obj = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;var address = &quot;北京市&quot;Object.defineProperty(obj, &#x27;address&#x27;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return address</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(value) &#123;</span><br><span class="line">    address = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)console.log(obj.address)</span><br><span class="line">obj.address = &quot;广州市&quot;</span><br><span class="line">console.log(obj.address)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-同时定义多个属性"><a href="#1-3-3-同时定义多个属性" class="headerlink" title="1.3.3. 同时定义多个属性"></a>1.3.3. 同时定义多个属性</h4><p>如果我们希望给对象同时定义多个属性的属性描述符，可以使用Object.defineProperties()</p>
<ul>
<li><strong>Object.defineProperties()</strong> 方法直接在一个对象上定义 <strong>多个</strong> 新的属性或修改现有属性，并且返回该对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  _age: 18</span><br><span class="line">&#125;Object.defineProperties(obj, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    writable: true,</span><br><span class="line">    value: &quot;why&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      return this._age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)console.log(obj.name)</span><br><span class="line">obj.name = &quot;kobe&quot;</span><br><span class="line">console.log(obj.name)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-对象方法的补充"><a href="#1-3-4-对象方法的补充" class="headerlink" title="1.3.4. 对象方法的补充"></a>1.3.4. 对象方法的补充</h4><p>获取对象的属性描述符：</p>
<ul>
<li><p>getOwnPropertyDescriptor</p>
</li>
<li><p>getOwnPropertyDescriptors</p>
</li>
</ul>
<p>禁止对象扩展新属性：<em>preventExtensions</em></p>
<ul>
<li>给一个对象添加新的属性会失败（在严格模式下会报错）；</li>
</ul>
<p>密封对象，不允许配置和删除属性：<em>seal</em></p>
<ul>
<li><p>实际是调用_preventExtensions_</p>
</li>
<li><p>并且将现有属性的_configurable:false_</p>
</li>
</ul>
<p>冻结对象，不允许修改现有属性： <em>freeze</em></p>
<ul>
<li><p>实际上是调用_seal_</p>
</li>
<li><p>并且将现有属性的_writable:_ <em>false</em></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1.getOwnPropertyDescriptor</span><br><span class="line">// &#123; value: &#x27;why&#x27;, writable: true, enumerable: true, configurable: true &#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(obj, &quot;name&quot;))</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj))// 2.禁止对象扩展</span><br><span class="line">Object.preventExtensions(obj)</span><br><span class="line">obj.height = 1.88</span><br><span class="line">console.log(obj.height)// 3.密封对象(不能删除和配置属性)</span><br><span class="line">Object.seal(obj)delete obj.name</span><br><span class="line">console.log(obj)// 4.冻结对象(不能修改属性)</span><br><span class="line">Object.freeze(obj)</span><br><span class="line">// 现有属性也不能修改</span><br><span class="line">obj.name = &quot;kobe&quot;</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure>

<h2 id="二-创建对象"><a href="#二-创建对象" class="headerlink" title="二. 创建对象"></a>二. 创建对象</h2><h3 id="2-1-如何创建多个对象"><a href="#2-1-如何创建多个对象" class="headerlink" title="2.1. 如何创建多个对象"></a>2.1. 如何创建多个对象</h3><p>如果我们现在希望创建一系列的对象：比如Person对象</p>
<ul>
<li>包括张三、李四、王五、李雷等等，他们的信息各不相同；</li>
</ul>
<p>那么采用什么方式来创建比较好呢？</p>
<p>目前我们已经学习了两种方式：</p>
<ul>
<li><p>new Object方式；</p>
</li>
<li><p>字面量创建的方式；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var p1 = &#123;</span><br><span class="line">  name: &quot;张三&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  height: 1.77,</span><br><span class="line">  address: &quot;北京市&quot;</span><br><span class="line">&#125;var p2 = &#123;</span><br><span class="line">  name: &quot;李四&quot;,</span><br><span class="line">  age: 20,</span><br><span class="line">  height: 1.87,</span><br><span class="line">  address: &quot;上海市&quot;</span><br><span class="line">&#125;var p3 = &#123;</span><br><span class="line">  name: &quot;王五&quot;,</span><br><span class="line">  age: 19,</span><br><span class="line">  height: 1.88,</span><br><span class="line">  address: &quot;杭州市&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式有一个很大的弊端：创建同样的对象时，需要编写重复的代码；</p>
<h3 id="2-2-工厂模式创建对象"><a href="#2-2-工厂模式创建对象" class="headerlink" title="2.2. 工厂模式创建对象"></a>2.2. 工厂模式创建对象</h3><p>我们可以想到的一种创建对象的方式：工厂模式</p>
<p>工厂模式其实是一种常见的设计模式；</p>
<ul>
<li>通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, height, address) &#123;</span><br><span class="line">  var p = new Object()</span><br><span class="line">  p.name = name</span><br><span class="line">  p.age = age</span><br><span class="line">  p.height = height</span><br><span class="line">  p.address = address  p.eating = function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;  p.running = function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在跑步~&quot;)</span><br><span class="line">  &#125;  return p</span><br><span class="line">&#125;var p1 = createPerson(&quot;张三&quot;, 18, 1.88, &quot;北京市&quot;)</span><br><span class="line">var p2 = createPerson(&quot;李四&quot;, 20, 1.68, &quot;上海市&quot;)</span><br><span class="line">var p3 = createPerson(&quot;王五&quot;, 25, 1.78, &quot;南京市&quot;)</span><br><span class="line">var p4 = createPerson(&quot;李雷&quot;, 19, 1.78, &quot;广州市&quot;)console.log(p1)</span><br><span class="line">console.log(p2)</span><br></pre></td></tr></table></figure>

<p>代码解析:</p>
<ul>
<li><p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象；</p>
</li>
<li><p>可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象；</p>
</li>
<li><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）；</p>
</li>
<li><p>随着JavaScript的发展，又一个新模式出现了；</p>
</li>
</ul>
<h3 id="2-3-构造函数创建对象"><a href="#2-3-构造函数创建对象" class="headerlink" title="2.3. 构造函数创建对象"></a>2.3. 构造函数创建对象</h3><h4 id="2-3-1-认识构造函数"><a href="#2-3-1-认识构造函数" class="headerlink" title="2.3.1. 认识构造函数"></a>2.3.1. 认识构造函数</h4><p>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</p>
<ul>
<li><p>但是从某些角度来说，这些对象应该有一个他们共同的类型；</p>
</li>
<li><p>下面我们来看一下另外一种模式：构造函数的方式；</p>
</li>
</ul>
<p>我们先理解什么是构造函数？</p>
<ul>
<li><p>构造函数也称之为构造器（constructor），通常是我们在创建对象时会调用的函数；</p>
</li>
<li><p>在其他面向的编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法；</p>
</li>
<li><p>但是JavaScript中的构造函数有点不太一样；</p>
</li>
</ul>
<p>JavaScript中的构造函数是怎么样的？</p>
<ul>
<li><p>构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别；</p>
</li>
<li><p>那么如果这么一个普通的函数被使用new操作符来调用了，那么这个函数就称之为是一个构造函数；</p>
</li>
</ul>
<p>那么被new调用有什么特殊的呢？</p>
<h4 id="2-3-2-new-操作符"><a href="#2-3-2-new-操作符" class="headerlink" title="2.3.2. new 操作符"></a>2.3.2. new 操作符</h4><p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p>
<ul>
<li><p>1.在内存中创建一个新的对象（空对象）；</p>
</li>
<li><p>2.这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；（后面详细讲）；</p>
</li>
<li><p>3.构造函数内部的this，会指向创建出来的新对象；</p>
</li>
<li><p>4.执行函数的内部代码（函数体代码）；</p>
</li>
<li><p>5.如果构造函数没有返回非空对象，则返回创建出来的新对象；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">&#125;var p1 = new Person()</span><br><span class="line">var p2 = new Person()</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-构造函数方式"><a href="#2-3-4-构造函数方式" class="headerlink" title="2.3.4. 构造函数方式"></a>2.3.4. 构造函数方式</h4><p>我们来通过构造函数实现一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, height, address) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.height = height</span><br><span class="line">  this.address = address  this.eating = function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  this.running = function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在跑步~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数可以确保我们的对象是有Person的类型的（实际是constructor的属性，这个我们后续再探讨）；</p>
<p>但是构造函数就没有缺点了吗？</p>
<ul>
<li>构造函数也是有缺点的，它在于我们需要为每个对象的函数去创建一个函数对象实例；</li>
</ul>
<h2 id="三-认识原型"><a href="#三-认识原型" class="headerlink" title="三. 认识原型"></a>三. 认识原型</h2><h3 id="3-1-认识对象的原型"><a href="#3-1-认识对象的原型" class="headerlink" title="3.1. 认识对象的原型"></a>3.1. 认识对象的原型</h3><p>JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。</p>
<p>那么这个对象有什么用呢？</p>
<ul>
<li><p>当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作；</p>
</li>
<li><p>这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它；</p>
</li>
<li><p>如果对象中没有改属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性；</p>
</li>
<li><p>这个 [[prototype]] 我们通常会将其称之为隐式原型；</p>
</li>
</ul>
<p>那么如果通过字面量直接创建一个对象，这个对象也会有这样的属性吗？如果有，应该如何获取这个属性呢？</p>
<ul>
<li><p>答案是有的，只要是对象都会有这样的一个内置属性；</p>
</li>
<li><p>获取的方式有两种：</p>
</li>
<li><p>方式一：通过对象的 <code>__proto__</code> 属性可以获取到（但是这个是早期浏览器自己添加的，存在一定的兼容性问题）；</p>
</li>
<li><p>方式二：通过 <code>Object.getPrototypeOf</code> 方法可以获取到；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;// 方式一: __proto__(有浏览器兼容问题)</span><br><span class="line">console.log(obj.__proto__)// 方式二: Object.getPrototypeOf</span><br><span class="line">console.log(Object.getPrototypeOf(obj))</span><br></pre></td></tr></table></figure>

<p>那么我们就可以进行如下的测试了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个obj对象</span><br><span class="line">var obj = &#123;&#125;// 直接给对象添加address属性</span><br><span class="line">// obj.address = &quot;北京市&quot;// 直接给隐式原型上添加address属性</span><br><span class="line">// 给__proto__上添加address属性</span><br><span class="line">obj.__proto__.address = &quot;广州市&quot;// 通过Object.setPrototypeOf来设置隐式原型</span><br><span class="line">Object.setPrototypeOf(obj, &#123; address: &quot;上海市&quot;, name: &quot;setPrototypeOf&quot; &#125;)console.log(obj.address)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-认识函数的原型"><a href="#3-2-认识函数的原型" class="headerlink" title="3.2. 认识函数的原型"></a>3.2. 认识函数的原型</h3><h4 id="3-2-1-函数的prototype"><a href="#3-2-1-函数的prototype" class="headerlink" title="3.2.1. 函数的prototype"></a>3.2.1. 函数的prototype</h4><p>那么我们知道上面的东西对于我们的构造函数创建对象来说有什么用呢？</p>
<ul>
<li>它的意义是非常重大的，接下来我们继续来探讨；</li>
</ul>
<p>这里我们又要引入一个新的概念：所有的函数都有一个prototype的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;// 所有的函数都有一个属性, 名字是 prototype </span><br><span class="line">console.log(foo.prototype)</span><br></pre></td></tr></table></figure>

<p>你可能会问题，老师是不是因为函数是一个对象，所以它有prototype的属性呢？</p>
<ul>
<li><p>不是的，因为它是一个函数，才有了这个特殊的属性；</p>
</li>
<li><p>而不是它是一个对象，所以有这个特殊的属性；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">console.log(obj.prototype) // obj就没有这个属性</span><br></pre></td></tr></table></figure>

<p>我们前面讲过new关键字的步骤如下：</p>
<ul>
<li><p>1.在内存中创建一个新的对象（空对象）；</p>
</li>
<li><p>2.这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；（后面详细讲）；</p>
</li>
<li><p>3.构造函数内部的this，会指向创建出来的新对象；</p>
</li>
<li><p>4.执行函数的内部代码（函数体代码）；</p>
</li>
<li><p>5.如果构造函数没有返回非空对象，则返回创建出来的新对象；</p>
</li>
</ul>
<p>我们将重心放到步骤一和二中：</p>
<ul>
<li><p>在内存中创建一个对象；</p>
</li>
<li><p>将对象的[[prototype]]属性赋值为该构造函数的prototype属性；</p>
</li>
</ul>
<p>那么也就意味着：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var p1 = new Person()// 上面的操作相当于会进行如下的操作:</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.__proto__ = Person.prototype</span><br></pre></td></tr></table></figure>

<p>那么也就意味着我们通过Person构造函数创建出来的所有对象的[[prototype]]属性都指向Person.prototype：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;var p1 = new Person()</span><br><span class="line">var p2 = new Person()</span><br><span class="line">var p3 = new Person()console.log(p1.__proto__ === p2.__proto__)</span><br><span class="line">console.log(p1.__proto__ === Person.prototype)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-创建对象的内存"><a href="#3-2-2-创建对象的内存" class="headerlink" title="3.2.2. 创建对象的内存"></a>3.2.2. 创建对象的内存</h4><p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXus1NwNcQzEZbOic8je5EuXcAooJw3H7iboGX02q9zdyukp41HicEzVMXRPopV7j7L0iaz1Y8TiaRwcAib3g/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXus1NwNcQzEZbOic8je5EuXcAooJw3H7iboGX02q9zdyukp41HicEzVMXRPopV7j7L0iaz1Y8TiaRwcAib3g/640?wx_fmt=jpeg"></a></p>
<p>对象对象的内存表现</p>
<h4 id="3-2-3-prototype属性"><a href="#3-2-3-prototype属性" class="headerlink" title="3.2.3. prototype属性"></a>3.2.3. prototype属性</h4><p>如果我们在函数的prototype中添加属性，那么创建的对象是否可以访问到呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;Person.prototype.name = &quot;why&quot;</span><br><span class="line">Person.prototype.age = 18var p1 = new Person()</span><br><span class="line">var p2 = new Person()console.log(p1.name, p1.age)</span><br><span class="line">console.log(p2.name, p2.age)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXus1NwNcQzEZbOic8je5EuXcAiaFq3CHEZLHW1TOq3x1aXjJccUrnIibGIIE42hkoDKE5yFvs2BwW7I5Q/640?wx_fmt=jpeg" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8xWXzAqXus1NwNcQzEZbOic8je5EuXcAiaFq3CHEZLHW1TOq3x1aXjJccUrnIibGIIE42hkoDKE5yFvs2BwW7I5Q/640?wx_fmt=jpeg"></a></p>
<p>代码的内存表现</p>
<h4 id="3-2-4-constructor属性"><a href="#3-2-4-constructor属性" class="headerlink" title="3.2.4. constructor属性"></a>3.2.4. constructor属性</h4><p>事实上原型对象上面是有一个属性的：constructor</p>
<ul>
<li>默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor) // [Function: Person]</span><br><span class="line">console.log(p1.__proto__.constructor) // [Function: Person]</span><br><span class="line">console.log(p1.__proto__.constructor.name) // Person</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-重写原型对象"><a href="#3-2-5-重写原型对象" class="headerlink" title="3.2.5. 重写原型对象"></a>3.2.5. 重写原型对象</h4><p>如果我们需要在原型上添加过多的属性，通常我们会重新整个原型对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;Person.prototype = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  eating: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们说过, 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性；</p>
<ul>
<li>而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是Person构造函数了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor) // [Function: Object]</span><br><span class="line">// 为什么是Object呢? 因为对象的字面量是由Object函数产生的</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">console.log(obj.constructor) // // [Function: Object]</span><br></pre></td></tr></table></figure>

<p>如果希望constructor指向Person，那么可以手动添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  eating: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方式虽然可以, 但是也会造成constructor的[[Enumerable]]特性被设置了true.</p>
<ul>
<li><p>默认情况下, 原生的constructor属性是不可枚举的.</p>
</li>
<li><p>如果希望解决这个问题, 就可以使用我们前面介绍的Object.defineProperty()函数了.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &quot;why&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  eating: function() &#123;</span><br><span class="line">    console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-组合构造函数和原型"><a href="#3-3-组合构造函数和原型" class="headerlink" title="3.3. 组合构造函数和原型"></a>3.3. 组合构造函数和原型</h3><p>我们在上一个构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数</p>
<p>那么有没有办法让所有的对象去共享这些函数呢?</p>
<ul>
<li>可以，将这些函数放到Person.prototype的对象上即可；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, height, address) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.height = height</span><br><span class="line">  this.address = address</span><br><span class="line">&#125;Person.prototype.eating = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在吃东西~&quot;)</span><br><span class="line">&#125;Person.prototype.running = function() &#123;</span><br><span class="line">  console.log(this.name + &quot;在跑步~&quot;)</span><br><span class="line">&#125;var p1 = new Person(&quot;why&quot;, 18, 1.88, &quot;广州市&quot;)</span><br><span class="line">var p2 = new Person(&quot;kobe&quot;, 30, 1.98, &quot;北京市&quot;)p1.eating()</span><br><span class="line">p2.running()</span><br></pre></td></tr></table></figure></div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-10-12</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>宇宙里有什么不是暂时</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


    <!--暗黑模式-->
    <script src="/js/darkmode-js.min.js"></script>
    <script>
        function addDarkmodeWidget() {
        const options = {
            bottom: '53px', // default: '32px'
            right: 'unset', // default: '32px'
            left: '42px', // default: 'unset'
            time: '0.3s', // default: '0.3s'
            mixColor: '#fff', // default: '#fff'
            backgroundColor: ' #e4e4e4 ',  // default: '#fff'
            buttonColorDark: '#100f2c',  // default: '#100f2c'
            buttonColorLight: '#fff', // default: '#fff'
            saveInCookies: true, // default: true,
            label: '🌓', // default: ''
            autoMatchOsTheme: true // default: true
        }
    
        const darkmode = new Darkmode(options);
        darkmode.showWidget();
        
        }
        window.addEventListener('load', addDarkmodeWidget);
    </script>
  
</html>