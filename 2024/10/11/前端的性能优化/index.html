<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="前端的性能优化" />
    <meta name="hexo-theme-A4" content="v1.9.6" />
    <link rel="alternate icon" type="image/webp" href="/images/cat.svg">
    <title>Blog</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/images/cat.svg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Blog</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    前端的性能优化
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2024-10-11</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：12k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：44分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-%E5%89%8D%E7%AB%AF%E5%88%B0%E5%BA%95%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87"><span class="post-toc-text">灵魂拷问-前端到底能做些什么？–性能优化篇</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-0-1-%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2CRP%EF%BC%88%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%89"><span class="post-toc-text">2.0.1 用户访问页面CRP（用户输入一个URL后会发生什么）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-0-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="post-toc-text">2.0.2 浏览器的进程和线程机制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-0-3-%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98-%E9%87%8D%E6%8E%92%EF%BC%88%E5%9B%9E%E6%B5%81%EF%BC%89"><span class="post-toc-text">2.0.3 页面重绘&amp;重排（回流）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-0-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="post-toc-text">2.1.0 优化思路</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-1-%E5%A2%9E%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F"><span class="post-toc-text">2.1.1 增加请求并发数量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-1-1-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%88%E7%A7%B0%E5%9F%9F%E5%90%8D%E5%88%86%E7%89%87%E3%80%81%E5%9F%9F%E5%90%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89"><span class="post-toc-text">2.1.1.1 使用多个域名（又称域名分片、域名负载均衡）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-1-2-%E5%8D%87%E7%BA%A7http2"><span class="post-toc-text">2.1.1.2 升级http2</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-1-3-%E5%8D%87%E7%BA%A7http3"><span class="post-toc-text">2.1.1.3 升级http3</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-2-%E7%BC%A9%E7%9F%AD%E5%8D%95%E6%AC%A1%E8%AF%B7%E6%B1%82%E6%97%B6%E9%97%B4"><span class="post-toc-text">2.1.2 缩短单次请求时间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-2-1-%E5%87%8F%E5%B0%91%E6%9E%84%E5%BB%BA%E4%BA%A7%E7%89%A9%E4%BD%93%E7%A7%AF"><span class="post-toc-text">2.1.2.1 减少构建产物体积</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-2-2-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E5%8E%8B%E7%BC%A9"><span class="post-toc-text">2.1.2.2 网络传输中压缩</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-2-3-%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8C%E5%85%B3%E9%94%AE%E6%8E%A5%E5%8F%A3"><span class="post-toc-text">2.1.2.3 缓存静态资源和关键接口</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-3-%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F"><span class="post-toc-text">2.1.3 优化资源请求顺序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-3-1-%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90%E5%B0%BD%E6%97%A9%E5%8A%A0%E8%BD%BD"><span class="post-toc-text">2.1.3.1 关键资源尽早加载</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-3-2-%E9%9D%9E%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD-%E6%89%A7%E8%A1%8C"><span class="post-toc-text">2.1.3.2 非关键资源延迟加载&amp;执行</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-0-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="post-toc-text">2.2.0 优化思路</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR"><span class="post-toc-text">2.2.1 服务端渲染SSR</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2-JS%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.2 JS代码性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-2-2-1-DOM%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.2.1 DOM优化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-2-2-2-%E5%87%BD%E6%95%B0%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.2.2 函数任务优化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-2-2-3-React%E4%B8%93%E9%A1%B9"><span class="post-toc-text">2.2.2.3 React专项</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-3-CSS%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.3 CSS代码性能优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-4-HTML%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.4 HTML代码性能优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-5-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.5 图片加载性能优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-6-%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="post-toc-text">2.2.6 动画性能优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-1-performance%E9%9D%A2%E6%9D%BF"><span class="post-toc-text">3.1.1 performance面板</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-2-lighthouse%E9%9D%A2%E6%9D%BF"><span class="post-toc-text">3.1.2 lighthouse面板</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-3-network%E9%9D%A2%E6%9D%BF"><span class="post-toc-text">3.1.3 network面板</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-4-%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%9D%A2%E6%9D%BF%EF%BC%88%E5%8D%B3%E5%B0%86%E8%A2%AB%E7%A7%BB%E9%99%A4%EF%BC%89"><span class="post-toc-text">3.1.4 性能数据分析面板（即将被移除）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-1-pagespeed"><span class="post-toc-text">3.2.1 pagespeed</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-2-webpagetest"><span class="post-toc-text">3.2.2 webpagetest</span></a></li></ol></li></ol></li></ol></li></ol>
            
        
        <div class=".article-gallery"><h1 id="灵魂拷问-前端到底能做些什么？–性能优化篇"><a href="#灵魂拷问-前端到底能做些什么？–性能优化篇" class="headerlink" title="灵魂拷问-前端到底能做些什么？–性能优化篇"></a>灵魂拷问-前端到底能做些什么？–性能优化篇</h1><p>原创 作者:硅步 公号:阿里云开发者 发布时间:2024-09-25 8:30 发表于浙江</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HezWSAsNFWE3UyO6fGjgHQ">灵魂拷问-前端到底能做些什么？–性能优化篇</a></p>
<p><a href="/img/0.jpeg" class="gallery-item" style="box-shadow: none;"> <img src="/img/0.jpeg"></a></p>
<p>阿里妹导读</p>
<p>作者最近在尝试对负责的平台进行性能优化，本文整理了些前端性能优化的一些常见策略。</p>
<blockquote>
<p>踏上取经路，比抵达灵山更重要。</p>
</blockquote>
<p>一、概览</p>
<p>最近在尝试对负责的平台进行性能优化，整理了一下前端性能优化的一些常见策略。一般性能优化的常见思路是：先进行性能现状分析定义出问题，然后针对问题结合性能优化策略给出技术方案并进行评估，最后再落地&amp;验证技术方案。工欲善其事，必先利其器，让我们跟随本文了解一下常见的性能优化策略。话不多说，先上大纲。</p>
<p>清晰大图见链接或点击文末阅读原文查看：</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1610662">https://developer.aliyun.com/article/1610662</a></p>
<p><a href="/img/1.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/1.png"></a></p>
<p>二、常见性能优化策略</p>
<p><strong>2.0 前置储备知识点</strong></p>
<h4 id="2-0-1-用户访问页面CRP（用户输入一个URL后会发生什么）"><a href="#2-0-1-用户访问页面CRP（用户输入一个URL后会发生什么）" class="headerlink" title="2.0.1 用户访问页面CRP（用户输入一个URL后会发生什么）"></a>2.0.1 用户访问页面CRP（用户输入一个URL后会发生什么）</h4><p>前端面试有一个很经典的问题：用户输入一个URL后会发生什么。这个问题可以很有效的考察候选人知识的广度，甚至于深度。一般来说，web端的性能优化，本质上就是尽可能缩短“用户输入一个URL”到“用户可以在网页上进行预期行为”这两个时间点的时间间隔。</p>
<p>因此，web性能优化一般会被纳入用户体验优化的一环。在一些C端场景，用户可以进行预期行为的耗时，和最终相关页面产生的收益有着很明显的正向关联，网络上可以找到一些相关案例。</p>
<p>所以，在进行性能优化前，我们需要了解我们要优化的东西是什么。也就引出了用户访问页面CRP（关键渲染路径）。简单点说，用户输入URL后一般经历如下环节。</p>
<ul>
<li><p>浏览器对输入URL的域名进行DNS解析获得IP地址；</p>
</li>
<li><p>基于IP地址和目标服务器建连接（http1.1 &#x2F; http2 &#x2F; http3）；</p>
</li>
<li><p>基于建立的连接，向服务器发送http请求；</p>
</li>
<li><p>目标服务器处理请求并返回http响应；</p>
</li>
<li><p>浏览器收到服务器的响应（我们只考虑先请求html的情况）返回html；</p>
</li>
<li><p>浏览器对html进行解析，基于html和js脚本构建dom树，基于css构建cssom树，合成渲染树；</p>
</li>
<li><p>结合渲染树和屏幕分辨率等相关信息计算节点布局信息；</p>
</li>
<li><p>浏览器基于渲染树和布局信息进行页面绘制；</p>
</li>
<li><p>最后将不同的图层合并为最终的图像，出现在页面上；</p>
</li>
</ul>
<p>核心公式：“用户访问页面耗时” &#x3D; “资源请求耗时” + “页面渲染耗时”。参考下方示意图：</p>
<p><a href="/img/2.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/2.png"></a></p>
<h4 id="2-0-2-浏览器的进程和线程机制"><a href="#2-0-2-浏览器的进程和线程机制" class="headerlink" title="2.0.2 浏览器的进程和线程机制"></a>2.0.2 浏览器的进程和线程机制</h4><p>优化策略中有涉及web worker 等概念，web worker是基于后台线程去运行的，所以在下图简单介绍下浏览器的进程和线程机制。</p>
<p><a href="/img/3.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/3.png"></a></p>
<h4 id="2-0-3-页面重绘-重排（回流）"><a href="#2-0-3-页面重绘-重排（回流）" class="headerlink" title="2.0.3 页面重绘&amp;重排（回流）"></a>2.0.3 页面重绘&amp;重排（回流）</h4><p>重绘是指当元素的外观（如颜色、背景、阴影等）发生变化时，浏览器需要重新绘制这些元素，但不需要重新计算它们的布局。重绘不会影响文档的结构，只是更新了元素的视觉表现。比如改变元素的背景颜色、修改文本的颜色或字体样式。</p>
<p>重排，又称回流，是指当元素的几何属性（如宽度、高度、位置等）发生变化时，浏览器需要重新计算元素的布局。这通常会导致整个文档的布局被重新计算，因此重排的开销比重绘要大得多。比如改变元素的大小（如宽度或高度）、添加或删除 DOM 元素、改变元素的边距、填充或边框。</p>
<p>重绘相对较轻量，通常不会显著影响性能。重排则可能导致性能问题，尤其是在频繁触发时，因为它会影响到整个文档的布局，可能导致多次重排和重绘。</p>
<p><strong>2.1 资源请求环节</strong></p>
<h4 id="2-1-0-优化思路"><a href="#2-1-0-优化思路" class="headerlink" title="2.1.0 优化思路"></a>2.1.0 优化思路</h4><p>首先我们定义出“资源请求耗时”的几个相关因素：请求并发数量、单次请求时间以及资源请求顺序。其中资源请求顺序并不能直接缩短“资源请求耗时”，但可以让“关键的资源”先完成请求，从而页面渲染先行启动。</p>
<h4 id="2-1-1-增加请求并发数量"><a href="#2-1-1-增加请求并发数量" class="headerlink" title="2.1.1 增加请求并发数量"></a>2.1.1 增加请求并发数量</h4><p>默认情况下，浏览器对同一域名下的并发请求数量有限制，通常为6-8 个。 这意味着浏览器在同一时间最多同时发送6-8 个请求给同一域名下的服务器。 超过这个数量的请求将会被排队等待。我们可以通过如下方案增加请求并发数量。</p>
<h5 id="2-1-1-1-使用多个域名（又称域名分片、域名负载均衡）"><a href="#2-1-1-1-使用多个域名（又称域名分片、域名负载均衡）" class="headerlink" title="2.1.1.1 使用多个域名（又称域名分片、域名负载均衡）"></a><strong>2.1.1.1 使用多个域名（又称域名分片、域名负载均衡）</strong></h5><p>域名分片（Domain Sharding）是一种优化技术，旨在提高网页加载速度和资源请求的并发性。其基本原理是将网站的静态资源（如图片、CSS、JavaScript文件等）分散到多个不同的域名或子域名上，以绕过浏览器对同一域名的并发请求限制。</p>
<ul>
<li><p>使用多个子域名</p>
</li>
<li><p>例如，如果你的主域名是example.com，可以使用static1.example.com、static2.example.com等子域名来托管静态资源。</p>
</li>
<li><p>使用不同的顶级域名</p>
</li>
<li><p>可以将资源分散到不同的顶级域名上，例如example1.com、example2.com等。</p>
</li>
<li><p>CDN支持</p>
</li>
<li><p>许多内容分发网络（CDN）允许你使用多个域名来分发内容。</p>
</li>
</ul>
<h5 id="2-1-1-2-升级http2"><a href="#2-1-1-2-升级http2" class="headerlink" title="2.1.1.2 升级http2"></a><strong>2.1.1.2 升级http2</strong></h5><p>HTTP&#x2F;2 是 HTTP 协议的第二个主要版本，旨在提高网络性能和效率。在 HTTP&#x2F;1.x 中，每个请求通常需要建立一个新的 TCP 连接（HTTP&#x2F;1.0），或者在同一连接上按顺序处理请求（HTTP&#x2F;1.1，Keep-Alive），这导致了连接建立和关闭的开销。HTTP&#x2F;2 允许多个请求和响应在同一连接上并发进行（多路复用特性），减少了连接的数量和延迟。下方介绍下HTTP2的多路复用以及其他特性。</p>
<ul>
<li><p>多路复用</p>
</li>
<li><p>HTTP&#x2F;2 允许在单个连接上并发发送多个请求和响应，而不需要等待前一个请求完成。这减少了延迟并提高了资源利用率。</p>
</li>
<li><p>头部压缩</p>
</li>
<li><p>HTTP&#x2F;2 使用 HPACK 算法对请求和响应头部进行压缩，减少了传输的数据量，特别是在请求头部较大的情况下。</p>
</li>
<li><p>服务端推送</p>
</li>
<li><p>服务器可以主动向客户端推送资源，而不需要客户端请求。这意味着服务器可以在客户端请求某个页面时，提前发送该页面所需的资源（如 CSS 和 JavaScript 文件）。</p>
</li>
<li><p>二进制分帧</p>
</li>
<li><p>HTTP&#x2F;2 使用二进制格式而不是文本格式，这使得解析更高效，减少了错误的可能性。</p>
</li>
<li><p>优先级和流控制</p>
</li>
<li><p>HTTP&#x2F;2允许客户端为请求设置优先级，服务器可以根据这些优先级来优化资源的发送顺序。此外，流控制机制可以防止某个流占用过多的带宽</p>
</li>
</ul>
<h5 id="2-1-1-3-升级http3"><a href="#2-1-1-3-升级http3" class="headerlink" title="2.1.1.3 升级http3"></a><strong>2.1.1.3 升级http3</strong></h5><p>HTTP&#x2F;3是超文本传输协议的第三个主要版本，它是基于QUIC（快速UDP互联网连接）协议构建的。QUIC最初是由Google设计的，旨在减少延迟并提高Web性能。HTTP&#x2F;3解决了HTTP&#x2F;2中存在的一些问题。</p>
<ul>
<li><p>减少连接建立时间</p>
</li>
<li><p>HTTP&#x2F;2 基于 TCP 和 TLS，需要多个往返时间（RTT）来完成握手。HTTP&#x2F;3 使用 QUIC 协议，它将加密和传输合并为一个过程，允许在一个 RTT 完成连接建立，在最佳情况下甚至可以在零 RTT 中恢复会话。</p>
</li>
<li><p>多路复用无阻塞</p>
</li>
<li><p>HTTP&#x2F;2 虽然支持多路复用，但 TCP 层的队头阻塞问题仍然存在。HTTP&#x2F;3 通过 QUIC 改进的多路复用能力，在 QUIC 中由于是基于数据报的 UDP，独立的流可以在其他流发生丢包时继续传输，解决了 TCP 的队头阻塞问题。</p>
</li>
<li><p>快速丢包恢复和拥塞控制</p>
</li>
<li><p>QUIC 实现了更快速的丢包恢复机制。TCP 需要等待一段时间来确认丢包，而 QUIC 可以利用更精细的确认机制来迅速响应丢包情况，并相应调整拥塞控制策略。</p>
</li>
<li><p>连接迁移</p>
</li>
<li><p>QUIC 支持连接迁移，允许客户端在网络环境变化（如从 Wi-Fi 切换到移动网络）时，保持现有的连接状态。在 HTTP&#x2F;2 这种情况通常会导致连接中断和需要重新建连。</p>
</li>
</ul>
<h4 id="2-1-2-缩短单次请求时间"><a href="#2-1-2-缩短单次请求时间" class="headerlink" title="2.1.2 缩短单次请求时间"></a>2.1.2 缩短单次请求时间</h4><p>我们比较粗暴的定义一下“单次请求时间”的计算公式，“单次请求时间” &#x3D; “目标资源体积” &#x2F; “用户网速”。其中我们作为平台方很难去提升“用户网速”，所以就尽可能降低“目标资源体积”。对于前端来说，“目标资源体积”约等于“前端构建产物体积”。这里常规思路有三个：一是从减少构建产物体积；二是网络传输过程中进行压缩；三是启用缓存，直接不请求。</p>
<h5 id="2-1-2-1-减少构建产物体积"><a href="#2-1-2-1-减少构建产物体积" class="headerlink" title="2.1.2.1 减少构建产物体积"></a><strong>2.1.2.1 减少构建产物体积</strong></h5><p>这一步我们一般结合具体前端工程去做。我所参与开发的前端工程项目使用的是koi4（基于umi4） + webpack，所以是基于koi4和umi体系去介绍的。和其他体系相比，原理都一样，具体工程实现的方案上可能会有差异。</p>
<ul>
<li><p>常用公共依赖umd + externals化</p>
</li>
<li><p>我们常用的基础依赖比如 react&#x2F;react-dom&#x2F;antd&#x2F;lodash&#x2F;moment 等等，一般不会发生变化。我们就通过umd方式配合externals对其进行加载使用，让其长久的缓存在本地即可，每次应用发布也不会导致这些固定缓存失效。这种方案，对于富文本&#x2F;图表类大依赖项目来说，还可以有效的提升开发体验。</p>
</li>
<li><p>这个改造第一个需要注意的是，在微前端架构下，不同子应用所使用的基础依赖版本可能不是那么统一，这个改造针对工程依赖体系统一的项目收益最大。有些依赖升不动的应用可以先放掉，提升roi。</p>
</li>
<li><p>第二个需要注意的是，三方依赖代码中有很多如 antd&#x2F;es&#x2F;Button 类的写法，如果此时只针对 antd 配置一个externals会发现antd还是会被打包到产物中。可以通过webpack插件等方式将所有组件的es引用方式也externals掉，确保产物中没有额外的antd。这个feature我们团队在koi4中进行了内置。lodash等同理。</p>
</li>
<li><p>代码共享还有module federation方案，不再赘述。</p>
</li>
<li><p>适当的代码分割策略（dynamicImport）</p>
</li>
<li><p>umi3有一个api是dynamicImport，在umi4中默认开启了这个feature，会按页拆包、按需加载。如果不开启这个feature，我们所有页面都会被打到同一个bundle（umi.js）中，导致首屏加载慢的可怕。我接手过的一个最夸张的项目umijs体积压缩后6MB+，经过简单改了一些配置：</p>
<p>（umd + externals + dynamicImport + runtimeImport + treeshaking），压缩后体积降低到了834KB。</p>
</li>
<li><p>微前端架构下，umi.js的体积不仅仅影响的是网络加载，还影响微前端架构下qiankun对umi.js的解析速度，从而影响各种性能指标。我们近期对umi.js入口文件体积进行了优化，用户访问链路上整体350KB的体积减少，让FCP从 1000ms -&gt; 750ms，其他指标 LDP&#x2F;LCP&#x2F;MCP由于也要前置经历FCP，也有类似效果的提升。</p>
</li>
</ul>
<p><a href="/img/4.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/4.png"></a></p>
<ul>
<li><p>开启Tree shaking</p>
</li>
<li><p>Tree shaking 是一种优化技术，主要用于 JavaScript 应用程序的构建过程中，尤其是在使用模块化系统（如 ES6 模块）时。它的主要作用是消除未使用的代码，从而减小最终生成的文件大小，提高加载速度和性能。</p>
</li>
<li><p>Tree shaking 通过package.json中增加 “sideEffects”: false开启，也可以配置绕过特定文件。开启Tree shaking 主要关注的是项目代码中有无“副作用”存在，如果有的话“副作用”代码被误干掉后会造成相关问题。但是常规项目一般也不会有这么多副作用。</p>
</li>
<li><p>我之前遇到的一段副作用代码是接手的代码中通过 import ‘xxx’ 引用执行了一段js脚本，导致开启 Tree shaking 后相关代码被干掉，从而页面白屏。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// edges/index.tsx</span></span><br><span class="line">import &#123; Graph, Path &#125; from <span class="string">&#x27;@antv/x6&#x27;</span>;</span><br><span class="line">import &#123; GraphEdge, GRID_SIZE &#125; from <span class="string">&#x27;../../constants&#x27;</span>;</span><br><span class="line">Graph.registerEdge(xxxx);</span><br><span class="line">Graph.registerConnector(xxx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line">import <span class="string">&#x27;./components/edges&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>打包压缩</p>
</li>
<li><p>umi中</p>
</li>
<li><p>cssMinifier，可以选择使用 esbuild &#x2F; cssnano &#x2F; parcelCSS 中的一个对css进行压缩，默认esbuild。</p>
</li>
<li><p>jsMinifier，可以使用 esbuild &#x2F; terser &#x2F; swc &#x2F; uglifyJs 中的一个对js进行压缩，默认esbuild。</p>
</li>
<li><p>html压缩，不同的打包体系也有不同的插件可以对html进行压缩，这个收益就比较低。</p>
</li>
<li><p>webpack</p>
</li>
<li><p>可以通过配置 TerserPlugin 来压缩JavaScript代码。</p>
</li>
<li><p>rollup</p>
</li>
<li><p>可以使用 rollup-plugin-terser 来压缩js代码。</p>
</li>
<li><p>其他工程体系</p>
</li>
<li><p>一般都会有对应的内置压缩插件。</p>
</li>
<li><p>umi4关闭不需要的插件</p>
</li>
<li><p>umi4会默认开启不少不需要的插件，可以按需关闭。</p>
</li>
<li><p>antd: false，如果将antd改造为umd+externals加载，一般我们就不需要这个，按需实现就好。</p>
</li>
<li><p>locale: false，按需配置就好。</p>
</li>
<li><p>helmet: false，如果你都没听过这个，那就直接关了吧。</p>
</li>
</ul>
<p><a href="/img/5.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/5.png"></a></p>
<h5 id="2-1-2-2-网络传输中压缩"><a href="#2-1-2-2-网络传输中压缩" class="headerlink" title="2.1.2.2 网络传输中压缩"></a><strong>2.1.2.2 网络传输中压缩</strong></h5><p>一般用的都是gzip压缩。gzip压缩是一种广泛使用的数据压缩技术，主要用于减少文件大小以提高传输效率。服务端或者nginx配置一下开启就好。我们如果使用DEF打包项目扔到CDN上的话，g.alicdn.com也默认支持gzip压缩。</p>
<p>工程中的压缩主要是通过删除无用代码等减小文件体积，gzip压缩是在文件在网络传输过程中进行压缩。</p>
<p><a href="/img/6.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/6.png"></a></p>
<h5 id="2-1-2-3-缓存静态资源和关键接口"><a href="#2-1-2-3-缓存静态资源和关键接口" class="headerlink" title="2.1.2.3 缓存静态资源和关键接口"></a><strong>2.1.2.3 缓存静态资源和关键接口</strong></h5><p>首先我们明确一下缓存对象：前端静态资源（如js&#x2F;css&#x2F;image等）以及对实时性要求不高但是在CRP中block后续渲染的接口（比如用户固定信息&#x2F;菜单数据）等等。我们目前常涉及的缓存方案包括：CDN边缘节点缓存、HTTP缓存、service-worker缓存以及web存储API（localstorage&#x2F;sessionstorage&#x2F;indexdb）。我们一般不用Web存储API缓存静态资源，因为其空间有限。</p>
<ul>
<li><p>CDN边缘节点缓存</p>
</li>
<li><p>CDN（内容分发网络）边缘节点缓存是指在CDN网络中的各个边缘节点（也称为缓存服务器）上存储的内容，以提高用户访问速度和降低源服务器负担。简单点说，就是拉近和终端用户的物理位置，缓存在离用户最近的CDN节点。</p>
</li>
<li><p>http缓存</p>
</li>
<li><p>http缓存分为 强缓存 和 协商缓存，http缓存流程如下。</p>
</li>
<li><p>如何判断强缓存是否过期？</p>
</li>
<li><p>Expires</p>
</li>
<li><p>Expires 是HTTP&#x2F;1.0引入的头部字段，用于指定一个特定的日期和时间，在这个时间点，响应被视为过期。它的值是一个HTTP日期格式的字符串（绝对时间）。</p>
</li>
<li><p>Cache-Control</p>
</li>
<li><p>Cache-Control 是HTTP&#x2F;1.1引入的头部字段，可以更精确地控制缓存策略。它可以包含多个指令，每个指令之间用逗号分隔。</p>
</li>
<li><p>public : 表示响应可以被任何缓存所存储。</p>
</li>
<li><p>private : 表示响应只能被单个用户的缓存存储，比如上方的CDN就无法缓存了。</p>
</li>
<li><p>no-cache : 强制缓存必须先去协商后端（即，再请求一次）再使用缓存。</p>
</li>
<li><p>no-store : 不允许缓存存储任何关于客户端请求或服务器响应的信息。</p>
</li>
<li><p>max-age&#x3D;<seconds> : 指定响应的最大缓存时间，单位为秒。超过这个时间，缓存会被视为过期。</p>
</li>
<li><p>must-revalidate : 表示缓存必须在使用过期数据之前进行重新验证。</p>
</li>
</ul>
<p><a href="/img/7.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/7.png"></a></p>
<ul>
<li><p>service worker缓存</p>
</li>
<li><p>service worker 是 PWA 的核心技术，用作网络浏览器和网络服务器之间的代理。它们旨在通过提供离线访问功能来提高可靠性，同时提升网页性能。</p>
</li>
<li><p>service worker 主要是针对弱网或者离线场景，在我们的 web性能优化 场景中，特别是中后台场景，相对于 http缓存 貌似并没有太大优势。</p>
</li>
<li><p>我们经过调研，准备用 service worker 采用 Stale While Revalidate缓存策略 缓存首次访问的html以及对实时性要求不高但是在CRP中block后续流程的接口。原因如下。</p>
</li>
<li><p>我们一般会向首屏html注入很多额外接口查询的数据，比如用户信息，导致对首屏html的访问有 150-300ms。经历了这150-300ms，后续请求和渲染流程才会启动。这个缓存策略可以提升全站访问速度 150-300ms（取决于html请求耗时）。</p>
</li>
<li><p>对实时性要求不高但是在CRP中block后续流程的接口，同理。至于这些接口为什么不尝试用localstorage等缓存？举个例子，我们的导航和加载器是umd方案引入的，如果每个都改造成本还是挺高的。通过 service worker 可以实现全局拦截。类似 filter 和 interceptor。</p>
</li>
<li><p>为什么采用 Stale While Revalidate 缓存策略？如果硬控html等10分钟，万一我们的某次发版存在bug，那就抓瞎了。</p>
</li>
<li><p>web存储API</p>
</li>
<li><p>web存储API 提供了几种机制来在客户端存储数据，使得web应用能够像桌面应用一样持久化数据。我们一般用 web存储API 对一些对实时性要求较低的数据接口（比如字典）进行缓存，提升页面性能。</p>
</li>
<li><p>localStorage</p>
</li>
<li><p>使用 localStorage 存储的数据是持久性的，这意味着除非用户或脚本显式地删除它，否则数据会一直存在。存储空间通常是 5MB 或更多。</p>
</li>
<li><p>sessionStorage</p>
</li>
<li><p>与 localStorage 不同，sessionStorage 中的数据只存在于浏览器的一个会话期间。当浏览器窗口关闭时，存储的数据会被清除。sessionStorage 的存储容量往往与 localStorage 相同，但在某些实现中可能会更少。</p>
</li>
<li><p>indexedDB</p>
</li>
<li><p>indexedDB 是一种客户端侧的 NoSQL 数据库技术，允许 Web 应用程序在用户浏览器中存储大量的结构化数据。与 localStorage 和 sessionStorage 相比，IndexedDB 提供了更加强大的数据存储功能，支持事务处理、索引以及复杂的查询能力。</p>
</li>
<li><p>一般 indexedDB 的存储空间在 250MB 及以上，如果用户同意的话，还可以进一步拓展。</p>
</li>
</ul>
<h4 id="2-1-3-优化资源请求顺序"><a href="#2-1-3-优化资源请求顺序" class="headerlink" title="2.1.3 优化资源请求顺序"></a>2.1.3 优化资源请求顺序</h4><h5 id="2-1-3-1-关键资源尽早加载"><a href="#2-1-3-1-关键资源尽早加载" class="headerlink" title="2.1.3.1 关键资源尽早加载"></a><strong>2.1.3.1 关键资源尽早加载</strong></h5><ul>
<li><p>dns-prefetch，DNS预获取</p>
</li>
<li><p>DNS预获取允许浏览器在页面加载早期就开始进行DNS查询。这对于跨域资源尤其有用，因为它可以减少由于DNS解析带来的延迟。用法如下。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;dns-prefetch&quot;</span> href=<span class="string">&quot;https://example.com&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>preconnect，域名预连接</p>
</li>
<li><p>预连接允许浏览器尽早建立与第三方资源服务器的连接。这包括DNS查询、TCP握手以及TLS协商。通过预连接，浏览器可以在实际请求资源之前就准备好网络连接，从而加速资源的下载。用法如下。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preconnect&quot;</span> href=<span class="string">&quot;https://fonts.gstatic.com&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果资源需要HTTPS连接，可以添加 crossorigin 属性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preconnect&quot;</span> href=<span class="string">&quot;https://fonts.gstatic.com&quot;</span> crossorigin&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>preload，提升资源加载的优先级</p>
</li>
<li><p>预加载允许开发者告知浏览器立即加载某些资源，即使这些资源不是立即需要的。这通常用于那些对用户体验至关重要的资源，比如关键css或js文件。通过预加载，浏览器可以在用户实际需要这些资源之前就提前加载它们，从而减少延迟。其中，as 属性指定了要预加载的资源类型。用法如下。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;/style.css&quot;</span> as=<span class="string">&quot;style&quot;</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;/script.js&quot;</span> as=<span class="string">&quot;script&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>prefetch，预加载其他页面用到的资源</p>
</li>
<li><p>预获取允许浏览器在空闲时间预先下载将来可能需要的资源。这通常用于那些用户可能会访问的下一个页面的资源，例如链接到的其他页面。预获取是在用户尚未请求资源之前就开始下载资源的技术，它有助于减少未来请求的延迟。用法如下。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;prefetch&quot;</span> href=<span class="string">&quot;/next-page.html&quot;</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;prefetch&quot;</span> href=<span class="string">&quot;/image.jpg&quot;</span> as=<span class="string">&quot;image&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，过度使用 preload 和 prefetch 可能会导致不必要的带宽消耗，因此应该谨慎选择哪些资源进行 preload 或 prefetch。preconnect 和 dns-prefetch 同理，按需合理使用最好。</li>
</ul>
<h5 id="2-1-3-2-非关键资源延迟加载-执行"><a href="#2-1-3-2-非关键资源延迟加载-执行" class="headerlink" title="2.1.3.2 非关键资源延迟加载&amp;执行"></a><strong>2.1.3.2 非关键资源延迟加载&amp;执行</strong></h5><ul>
<li><p>async</p>
</li>
<li><p>对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。</p>
</li>
<li><p>对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会被并行请求，并尽快解析和执行。</p>
</li>
<li><p>defer</p>
</li>
<li><p>defer属性的作用是告诉浏览器在HTML文档解析完成后且页面加载之前执行脚本。这样可以确保脚本不会阻塞页面渲染，并且所有元素都在DOM中可用。defer 会阻塞DOMContentLoaded事件触发。</p>
</li>
<li><p>关于async 和 defer的几个注意事项</p>
</li>
<li><p>async 和 defer 这两个属性会让相应js执行不阻塞主线程，但是其加载还是按正常顺序加载的。</p>
</li>
<li><p>执行只是延后，但是还是会在主线程上执行。</p>
</li>
<li><p>async设置后，其执行顺序是不确定的；如果对执行顺序有要求，可以使用defer。</p>
</li>
<li><p>按需加载</p>
</li>
<li><p>对于公共依赖，我们团队同学开发了一个umi插件——umi-plugin-runtime-import[1]（umi-plugin-runtime-import-v4[2]，针对umi4）。比如我们进行上方 umd + externals 加载方案改造的话，大量的umd前置加载会让首屏加载不堪重负。如果使用async方案的话，可能会出现页面代码执行了，umd还没执行完，从而引发白屏。runtimeImport插件可以对这些umd实现按需引入，只有当页面中使用了这个umd对应的依赖，才会去加载。从而解决 umd + externals 改造带来的首屏加载问题。</p>
</li>
<li><p>针对页面级别代码，umi自带dynamicImport实现按页拆包，按需加载机制。</p>
</li>
<li><p>这两个方案虽然是umi的插件机制，但是底层都是使用了 webpack 相关能力，其他工程体系也可以参考实现自己的方案。</p>
</li>
</ul>
<p><strong>2.2 页面渲染环节</strong></p>
<h4 id="2-2-0-优化思路"><a href="#2-2-0-优化思路" class="headerlink" title="2.2.0 优化思路"></a>2.2.0 优化思路</h4><p>资源请求环节的优化是为了让页面渲染的资源尽可能快的ready，然后进行页面的渲染。在页面渲染环节，我们回顾一下页面渲染CRP。</p>
<ul>
<li><p>浏览器对html进行解析，基于html和js脚本构建dom树，基于css构建cssom树，合成渲染树；</p>
</li>
<li><p>结合渲染树和屏幕分辨率等相关信息计算节点布局信息；</p>
</li>
<li><p>浏览器基于渲染树和布局信息进行页面绘制；</p>
</li>
<li><p>最后将不同的图层合并为最终的图像，出现在页面上；</p>
</li>
</ul>
<p>首先，肯定离不开SSR这个老生常谈的优化方案。其次，我们当前重点关注CRP中几个常规web场景下的性能影响因素：JS代码、CSS代码、HTML代码、图片加载以及动画。可能不同业务场景下关注的重点不一样，其他的比如 WebGL、视频编码解码以及文档编辑器等等不再展开。</p>
<h4 id="2-2-1-服务端渲染SSR"><a href="#2-2-1-服务端渲染SSR" class="headerlink" title="2.2.1 服务端渲染SSR"></a>2.2.1 服务端渲染SSR</h4><ul>
<li><p>SSR（Server-Side Rendering，服务器端渲染）是一种网页渲染技术，它在服务器上生成完整的 HTML 页面，然后将其发送到客户端（浏览器）。与客户端渲染（CSR）相比，SSR 在用户请求页面时，服务器会处理所有的渲染逻辑，并将生成的页面直接返回给用户。</p>
</li>
<li><p>优点：更快的首屏加载时间；SEO 友好；更好的性能，降低一部分客户端负担。</p>
</li>
<li><p>缺点：需要服务器资源，且流量高场景下服务器负担较重，可能非C端场景团队内推动SSR不是那么容易；开发较复杂，特别是处理数据获取和状态管理时；交互存在延迟，也就是SSR页面初次加载时需要额外的js才能实现动态交互。</p>
</li>
<li><p>总结：真正使用还是要考虑场景和roi，相对SSR带来的收益，启用SSR带来的成本是否可以接受。</p>
</li>
</ul>
<h4 id="2-2-2-JS代码性能优化"><a href="#2-2-2-JS代码性能优化" class="headerlink" title="2.2.2 JS代码性能优化"></a>2.2.2 JS代码性能优化</h4><h5 id="2-2-2-1-DOM优化"><a href="#2-2-2-1-DOM优化" class="headerlink" title="2.2.2.1 DOM优化"></a><strong>2.2.2.1 DOM优化</strong></h5><ul>
<li><p>减少 DOM 操作</p>
</li>
<li><p>DOM 操作通常是性能瓶颈，因为每次对 DOM 的修改都会导致浏览器重新计算样式、布局和重绘。减少 DOM 操作可以显著提高性能。</p>
</li>
<li><p>批量进行 DOM 更改</p>
</li>
<li><p>批量更新 是指将多个 DOM 操作合并为一次操作，以减少重排和重绘的次数。通常可以用 DocumentFragment 和 innerHTML 方案实现。</p>
</li>
<li><p>简化 HTML 代码</p>
</li>
<li><p>简化 HTML 代码是指减少不必要的 DOM 节点和复杂的结构，以提高性能。包括减少嵌套、移除不必要的元素。</p>
</li>
<li><p>使用 虚拟DOM</p>
</li>
<li><p>现代前端框架中，其实我们已经很少直接操作 DOM，而是使用 React 和 Vue 这类采用了虚拟DOM技术的前端框架。虚拟DOM 通过在内存中维护一个虚拟的 DOM 树，减少直接对真实 DOM 的操作，从而提高了性能和响应速度。</p>
</li>
<li><p>由于 虚拟DOM 本身特性（新旧树Diff）原因，在如下场景会导致一些性能问题：频繁的状态更新、组件树过于庞大等。不过这些问题目前也有成熟的解决方案。</p>
</li>
<li><p>事件委托</p>
</li>
<li><p>事件委托是一种高效的事件处理技术，主要用于减少事件处理程序的数量，提高性能和简化代码。它的基本原理是将事件处理程序添加到父元素上，而不是每个子元素上。</p>
</li>
<li><p>比如一个卡片包含100个循环渲染出来的数字，我们要对数字点击进行监听。一种方式是给每个数字上加监听，这样就要加100个监听器。另外一种方式就是直接给卡片添加一个监听器，结合事件冒泡机制，通过event.target判断是对哪个数字的点击，从而执行相应的操作。</p>
</li>
<li><p>及时删除不再需要的事件监听器</p>
</li>
<li><p>不再赘述，不用了就及时清理，减少内存占用，避免意外行为。</p>
</li>
</ul>
<h5 id="2-2-2-2-函数任务优化"><a href="#2-2-2-2-函数任务优化" class="headerlink" title="2.2.2.2 函数任务优化"></a><strong>2.2.2.2 函数任务优化</strong></h5><ul>
<li><p>Web Worker</p>
</li>
<li><p>Web Worker 是一种在浏览器中运行 JavaScript 的机制，允许开发者在后台线程中执行脚本，从而实现多线程处理。它的主要目的是提高网页的性能，尤其是在处理大量计算或 I&#x2F;O 操作时，避免阻塞主线程（UI 线程）。详情参考 MDN Web Workers API[3]。</p>
</li>
<li><p>WebGPU</p>
</li>
<li><p>WebGPU 是一种新的 Web API，旨在为网页提供高性能的图形和计算能力。它允许开发者利用 GPU（图形处理单元）进行并行计算，从而加速图形渲染和数据处理。详情参考 MDN WebGPU API[4]。</p>
</li>
<li><p>长任务处理</p>
</li>
<li><p>在 JavaScript 中，长任务指的是那些需要较长时间才能完成的操作，例如复杂的计算、大量的数据处理或网络请求等。这些长任务如果在主线程中执行，会导致用户界面冻结，影响用户体验。</p>
</li>
<li><p>针对长任务，常见处理策略如下</p>
</li>
<li><p>将长任务分解为多个小任务，并使用 setTimeout 或 setInterval 将它们分批执行。这样可以让浏览器有机会处理其他事件（如用户输入、渲染等）。</p>
</li>
<li><p>将长任务移到 Web Worker 中执行。Web Worker 在后台线程中运行，不会阻塞主线程，适合处理复杂计算或大量数据。</p>
</li>
<li><p>对于需要频繁更新 UI 的长任务，可以使用 requestAnimationFrame 来分解任务。这样可以在浏览器的重绘周期内执行任务，确保流畅的动画效果。</p>
</li>
<li><p>节流</p>
</li>
<li><p>节流是一种限制函数在一定时间内只能执行一次的技术。它通常用于处理高频率的事件，确保在指定的时间间隔内只执行一次目标函数。</p>
</li>
<li><p>常见使用场景：滚动事件处理、窗口调整大小事件（与防抖结合使用）、定时更新数据（如 API 请求）等。</p>
</li>
<li><p>防抖</p>
</li>
<li><p>防抖是一种确保某个函数在一定时间内只被调用一次的技术。它通常用于处理用户输入事件，确保在用户停止输入后再执行某个操作。</p>
</li>
<li><p>常见使用场景：输入框的实时搜索建议、窗口调整大小事件、表单提交按钮的防止重复点击等。</p>
</li>
</ul>
<h5 id="2-2-2-3-React专项"><a href="#2-2-2-3-React专项" class="headerlink" title="2.2.2.3 React专项"></a><strong>2.2.2.3 React专项</strong></h5><p>React18引入了useTransition和useDeferredValue两个钩子，用于管理渲染性能，特别是在并发模式下。</p>
<p>React19 计划引入“自动记忆化”，即：不用手动编写 useMemo useCallback memo 来进行性能优化，通过全新编译器，React 19 可以自动检测组件的状态变化，并智能地决定是否要重新渲染。</p>
<ul>
<li><p>hooks</p>
</li>
<li><p>useCallback &#x2F; useMemo</p>
</li>
<li><p>useCallback &#x2F; useMemo 都是为了优化性能而设计的Hooks，它们可以帮助我们在组件重新渲染时避免不必要的计算或函数创建</p>
</li>
<li><p>一般useMemo用来缓存值，useCallback用来缓存函数，不再赘述。详情自行参考文档：useMemo[5]、useCallback[6]。</p>
</li>
<li><p>useTransition（React18）</p>
</li>
<li><p>允许使用者标记一些状态更新为次要更新（non-urgent updates），从而让这些更新在用户交互暂停期间执行。这样可以避免由于大量数据更新导致的UI卡顿，提高应用的响应性。</p>
</li>
<li><p>useDeferredValue（React18）</p>
</li>
<li><p>与 useTransition 类似，但是它专门用于延迟某些值的变化，直到当前工作完成。这通常用于列表滚动或者其他需要立即响应的情况，比如滚动一个长列表时，希望在滚动结束后再更新某些值。</p>
</li>
<li><p>memo</p>
</li>
<li><p>memo 是一个高阶组件（Higher-Order Component，HOC），它用于优化纯函数组件的性能。主要作用是在组件的props未发生改变时避免不必要的重新渲染，从而提高应用的性能。</p>
</li>
<li><p>Fragment</p>
</li>
<li><p>Fragment 允许使用者将子元素列表分组，而无需添加额外的DOM节点到最终渲染的HTML结构中。</p>
</li>
<li><p>可以用于简化 DOM结构，减少 DOM嵌套。</p>
</li>
<li><p>优化列表渲染（Key）</p>
</li>
<li><p>React 可以使用 key 对列表渲染进行优化，key 的主要作用是帮助 React 标识哪个元素已被添加、移除或改变，从而使得 React 能够更高效地更新 DOM。正确使用 key 属性可以在 React 渲染大量列表时提高性能并减少内存消耗。</p>
</li>
<li><p>另外 Key 也可以用在非列表场景，比如：动态组件、条件渲染、HOC等。</p>
</li>
<li><p>懒加载</p>
</li>
<li><p>React 懒加载（Lazy Loading）是一种优化技术，用于在需要时按需加载组件，而不是一开始就加载所有的组件。此法可以显著提高应用的启动速度和性能，特别是对于大型应用或者有很多组件的应用。</p>
</li>
<li><p>React 中一般使用 lazy + Suspense 组合使用实现懒加载。针对使用了 lazy 的组件文件，打包工具会自动将其分割成单独的代码块，并在需要时按需加载。</p>
</li>
<li><p>虚拟滚动</p>
</li>
<li><p>虚拟滚动（Virtual Scrolling）是一种优化技术，用于高效地渲染大量数据的列表。当列表中的元素非常多时，如果一次性渲染所有元素，会导致性能问题，特别是在移动设备上。虚拟滚动通过只渲染当前可视区域内的元素来解决这个问题，从而大大减少内存占用和提高渲染性能。</p>
</li>
<li><p>虚拟滚动是一种通用技术方案，不限于 React。一般相关的适用场景，通过三方包直接接入即可。我一般直接用 ahooks 的 useVirtual，antd 中的相关组件也大多支持 virtual 选项，直接用即可。</p>
</li>
<li><p>使用合适的状态管理</p>
</li>
<li><p>合适的状态管理方案可以帮助我们更好地控制状态更新的时机和范围，从而减少不必要的重新渲染。</p>
<p>例如，使用 Redux 或 MobX 等状态管理库，我们可以更精细地控制哪些组件需要重新渲染。特别是大型或复杂的 React 应用。</p>
</li>
<li><p>SWR</p>
</li>
<li><p>SWR 是一个用于优化 React 应用程序中数据获取的 JavaScript 库，它由 Vercel（前身为 Zeit）开发并维护。SWR 的名字来源于其主要功能：“Stale While Revalidate”，这是一种缓存策略，旨在提高用户体验，减少延迟。</p>
</li>
<li><p>ahooks 中的 useRequest[7] 也是支持 SWR 的，但是看其 代码[8] 是缓存在内存中的。这样刷新页面后缓存的数据就会丢失，没办法达到 我关闭浏览器后重新访问仍能最快速度拿到数据 的效果。为了解决这个问题，我们自己实现了一下，并将数据缓存在 indexedDB中。</p>
</li>
<li><p>qiankun相关</p>
</li>
<li><p>prefetch</p>
</li>
<li><p>比较核心的子应用可以 prefetch。我们有一个页面 PV 超级高，且不是站点首页，甚至代码都不和站点首页在一起。这个页面所在子应用是由于业务因素中途接入进来，并且在其他地方也有引用，且还在持续迭代，也没法直接把这个页面搬运到我们主应用中来减少中间加载环节。</p>
</li>
<li><p>这个场景下，我尝试对这个页面所在子应用进行了 prefetch，通过 AEM 性能数据对比观察，有一定收益。</p>
</li>
<li><p>优化entry js文件体积</p>
</li>
<li><p>优化 entry js 体积有两个考虑。第一个，参考上方，让资源请求更快。第二个，子应用加载时，qiankun 会对 entry js 进行解析，这个解析过程也是耗时的。一般entry js体积越大，耗时越多，并且每次重新生成子应用都要经历一次解析过程。资源请求可以通过缓存优化，但这个解析耗时我们目前很难优化（下方贴两个 qiankun 优化 entry js 解析耗时的链接，有兴趣可以看看），所以优化 entry js 体积也会有一些受益。</p>
</li>
<li><p>[RFC] qiankun的极致性能优化思路，与import-html-entry有关。[9]</p>
</li>
<li><p>改了 3 个字符，10倍的沙箱性能提升？！！[10]</p>
</li>
<li><p>关于优化 entry js 体积，我最近有过两次实践。</p>
</li>
<li><p>第一个是接入一个临时接手的子应用，该子应用由于历史背景+年久失修，umi js 高达6MB+（gzip压缩后）。我是把这个子应用部分页面嵌入到抽屉里，每次用户首次打开抽屉都要经历 5-6S 的转圈时间（qiankun 解析该子应用 umi.js 耗时）。我做了两次优化，第一次，将该 umi.js 体积 从 6MB+ 降低到了 1.8MB，转圈时间缩短到了 2-3S；第二次，将该 umi.js 体积 从 1.8MB 降低到了 834KB，目前转圈时间缩短到了 1S 以内。</p>
</li>
<li><p>第二个是针对我所负责的站点进行了一系列的优化，所有子应用 umi.js 体积降低 120KB - 200KB 不等，站点FCP 降低 200ms+。详见 2.1.2.1 减少构建产物体积——FCP75分位图。</p>
</li>
</ul>
<h4 id="2-2-3-CSS代码性能优化"><a href="#2-2-3-CSS代码性能优化" class="headerlink" title="2.2.3 CSS代码性能优化"></a>2.2.3 CSS代码性能优化</h4><ul>
<li><p>CSS 模块化</p>
</li>
<li><p>可以通过社区成熟的 CSS Modules 方案，模块化CSS，达到按需加载的效果，只加载需要内容。</p>
</li>
<li><p>CSS 精灵图</p>
</li>
<li><p>CSS 精灵图[11] 是一种面试常说，但是我还没实践过的方案。精灵图将我们希望在站点上使用的多个小图像（例如图标）放入单个图像文件中，然后使用不同的 background-position[12] 值在不同的位置显示图像的一部分。这可以大大减少获取图像所需的 HTTP 请求数量。</p>
</li>
<li><p>但是在 HTTP&#x2F;2 和 HTTP&#x2F;3 中，由于引入了多路复用等新特性，精灵图的优势已经不像在 HTTP&#x2F;1.x 时代那样明显。</p>
</li>
<li><p>CSS Containment</p>
</li>
<li><p>用 CSS 实现按需渲染的一种方案。CSS Containment 可以指示浏览器将页面的不同部分隔离开来，并独立地优化它们的渲染。这可以在渲染各个部分时提高性能。例如，可以指定浏览器在特定容器于视口中可见之前不要渲染它们。具体使用包括：contain、content-visibility。</p>
</li>
<li><p>contain，允许开发者精确指定要应用于页面上各个容器的 Containment 类型。这使得浏览器可以针对 DOM 的一部分重新计算布局、样式、绘制、大小或它们的任意组合。</p>
</li>
<li><p>content-visibility，允许开发者在一组容器上应用一组强大的局限，并指定浏览器在需要之前不要布局和渲染这些容器。</p>
</li>
<li><p>优化 CSS 写法</p>
</li>
<li><p>删除不必要的样式。所有脚本都会被解析，无论它在布局与绘制时是否被使用，因此删除无用样式可以加速网页渲染。目前似乎没有什么低成本方案去除打包产物中无用的CSS，我们编码时要养成好习惯。</p>
</li>
<li><p>不要将样式应用于不需要的元素。比如将通用选择器将样式应用于所有元素，这种类型的样式会对性能产生负面影响，特别是在较大的站点上。</p>
</li>
<li><p>简化选择器。冗余的选择器不仅会增加文件大小，还会增加解析的时间。</p>
</li>
</ul>
<h4 id="2-2-4-HTML代码性能优化"><a href="#2-2-4-HTML代码性能优化" class="headerlink" title="2.2.4 HTML代码性能优化"></a>2.2.4 HTML代码性能优化</h4><ul>
<li><p>响应式处理替代元素</p>
</li>
<li><p>借助 CSS 媒体查询 技术，实现根据设备尺寸，提供不同尺寸图像。以此来提高性能。比如移动设备只需下载适合其屏幕的图像，无需下载更大的桌面图像。</p>
</li>
<li><p>要根据设备的分辨率和视口大小提供相同图像的不同分辨率版本，我们可以使用 srcset 和 sizes 这两个属性。srcset 提供源图像的固有尺寸以及它们的文件名，而 sizes 在每种情况下提供媒体查询和需要填充的图像槽宽度。然后，浏览器根据每个槽位决定加载哪些图像。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">  srcset=<span class="string">&quot;480w.jpg 480w, 800w.jpg 800w&quot;</span></span><br><span class="line">  sizes=<span class="string">&quot;(max-width: 600px) 480px, 800px&quot;</span></span><br><span class="line">  src=<span class="string">&quot;800w.jpg&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为图像和视频提供不同来源</p>
</li>
<li><p>picture 基于 img，允许我们为不同的屏幕尺寸提供多个不同的源。例如，如果布局是宽的，我们可能希望有一个宽的图像；如果是窄的，我们会希望有一个在该上下文中仍然有效的较窄的图像。source 的 media 属性中包含媒体查询。如果媒体查询返回 true，则加载 source 的 srcset 属性引用的图像。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">  &lt;source media=<span class="string">&quot;(max-width: 799px)&quot;</span> srcset=<span class="string">&quot;narrow-banner-480w.jpg&quot;</span> /&gt;</span><br><span class="line">  &lt;source media=<span class="string">&quot;(min-width: 800px)&quot;</span> srcset=<span class="string">&quot;wide-banner-800w.jpg&quot;</span> /&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;large-banner-800w.jpg&quot;</span> alt=<span class="string">&quot;Dense forest scene&quot;</span> /&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>video 类似 picture，但在使用上存在一些差异。video中，源文件使用的是 src 而不是 srcset；另外多了一个 type 属性指定视频格式，浏览器将加载其支持（媒体查询测试返回 true）的首个格式。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls&gt;</span><br><span class="line">  &lt;source src=<span class="string">&quot;video/smaller.mp4&quot;</span> type=<span class="string">&quot;video/mp4&quot;</span> /&gt;</span><br><span class="line">  &lt;source src=<span class="string">&quot;video/smaller.webm&quot;</span> type=<span class="string">&quot;video/webm&quot;</span> /&gt;</span><br><span class="line">  &lt;source src=<span class="string">&quot;video/larger.mp4&quot;</span> type=<span class="string">&quot;video/mp4&quot;</span> media=<span class="string">&quot;(min-width: 800px)&quot;</span> /&gt;</span><br><span class="line">  &lt;source</span><br><span class="line">    src=<span class="string">&quot;video/larger.webm&quot;</span></span><br><span class="line">    type=<span class="string">&quot;video/webm&quot;</span></span><br><span class="line">    media=<span class="string">&quot;(min-width: 800px)&quot;</span> /&gt;</span><br><span class="line">  &lt;!-- fallback <span class="keyword">for</span> browsers that don<span class="number">&#x27;</span>t support video element --&gt;</span><br><span class="line">  &lt;a href=<span class="string">&quot;video/larger.mp4&quot;</span>&gt;download video&lt;/a&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>iframe懒加载</p>
</li>
<li><p>通过给 iframe 设置 loading&#x3D;”lazy” 属性，我们可以指示浏览器对最初屏幕外的 iframe 内容进行懒加载。</p>
</li>
</ul>
<h4 id="2-2-5-图片加载性能优化"><a href="#2-2-5-图片加载性能优化" class="headerlink" title="2.2.5 图片加载性能优化"></a>2.2.5 图片加载性能优化</h4><ul>
<li><p>适当的缩放、裁剪、压缩</p>
</li>
<li><p>当我们收到设计同学给的图，如果展示要求不是那么高的话，我们可以相关平台或者工具对图片进行二次处理（比如缩放、裁剪、压缩等），降低图片体积。</p>
</li>
<li><p>合适的图片格式</p>
</li>
<li><p>webp 格式的图片比 png&#x2F;jpg 有着更优秀的算法，在图片体积上会比 jpg&#x2F;png 更小，从而加载的更快、耗费的带宽更少。下图是 webp 兼容性情况。</p>
</li>
</ul>
<p><a href="/img/8.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/8.png"></a></p>
<ul>
<li><p>响应式加载</p>
</li>
<li><p>参考 2.2.4 HTML代码性能优化–为图像和视频提供不同来源。本质就是不同尺寸屏幕加载不同体积大小的图片，根据实际情况按需加载，不浪费带宽。</p>
</li>
<li><p>load&#x3D;”lazy”</p>
</li>
<li><p>loading&#x3D;”lazy” 属性值表示该图片应该使用懒加载（Lazy Loading）的方式加载，即只有当图片即将进入视口时才开始加载。类似 CSS Containment，给图片应用 content-visibility，也可以实现类似懒加载效果。</p>
</li>
<li><p>两者的区别是，设置 load&#x3D;”lazy” 后，图片资源的网络请求不会在解析 img 标签时直接发出，而是接近视口时才发出；而 content-visibility 控制的只是渲染，和图片资源的网络请求无关。</p>
</li>
<li><p>fetch-priority&#x3D;”high”</p>
</li>
<li><p>fetch-priority 属性允许开发者明确指定某些资源的加载优先级，当我们希望某些关键资源（如重要的图片或样式表）能够尽快加载时，可以使用 fetch-priority&#x3D;”high”。</p>
</li>
<li><p>decoding&#x3D;”async” </p>
</li>
<li><p>decoding&#x3D;”async” 可以指示浏览器异步解码图片，从而提高页面的渲染性能。这个属性特别适用于那些不需要立即显示的图片，例如位于页面底部的图片或懒加载的图片。</p>
</li>
</ul>
<h4 id="2-2-6-动画性能优化"><a href="#2-2-6-动画性能优化" class="headerlink" title="2.2.6 动画性能优化"></a>2.2.6 动画性能优化</h4><ul>
<li><p>动画使用原则</p>
</li>
<li><p>去除任何非必要的动画、尽可能简化动画 或者 懒加载动画。特别是中后台场景，避免滥用。</p>
</li>
<li><p>动画实现原则</p>
</li>
<li><p>尽量在 GPU 上进行动画处理</p>
</li>
<li><p>使用3D变换动画，例如 transform: translateZ() 和 rotate3d()。</p>
</li>
<li><p>具有某些其他属性动画的元素，例如 position: fixed。</p>
</li>
<li><p>应用了 will-change 的元素。</p>
</li>
<li><p>特定的在其自己层中渲染的元素，包括 <video>、<canvas> 和 <iframe>。</p>
</li>
<li><p>优先使用 CSS 实现</p>
</li>
<li><p>尽可能避免使用如下属性</p>
</li>
<li><p>修改元素的尺寸，例如 width、height、border 和 padding。</p>
</li>
<li><p>重新定位元素，例如 margin、top、bottom、left 和 right。</p>
</li>
<li><p>更改元素的布局，例如 align-content、align-items 和 flex。</p>
</li>
<li><p>添加改变元素几何形状的视觉效果，例如 box-shadow。</p>
</li>
<li><p>优先使用如下属性，减少重排（回流）</p>
</li>
<li><p>opacity</p>
</li>
<li><p>filter</p>
</li>
<li><p>变换</p>
</li>
<li><p>其次可使用 Web Animations API 实现</p>
</li>
<li><p>Web Animations API 提供了许多高级功能来帮助开发者创建更高效、更流畅的动画效果。比如细粒度的控制、关键帧管理、动画合成等等。</p>
</li>
<li><p>可以同时结合使用 requestAnimationFrame 实现</p>
</li>
<li><p>requestAnimationFrame 可以保证回调函数在浏览器的下一个重绘（repaint）之前调用，这确保了动画帧之间的同步性，意味着动画会尽可能地与浏览器的刷新频率同步，从而提供更流畅的视觉效果。同时浏览器会智能地调度 requestAnimationFrame 回调，当页面不可见（例如最小化窗口或切换到另一个标签页）时，动画会自动暂停，从而节省计算资源。</p>
</li>
</ul>
<p>三、常见分析工具</p>
<p>可以通过网络自行研究用法。</p>
<p><strong>3.1 chrome自带分析工具</strong></p>
<h4 id="3-1-1-performance面板"><a href="#3-1-1-performance面板" class="headerlink" title="3.1.1 performance面板"></a>3.1.1 performance面板</h4><ul>
<li>用于分析测试网页性能。</li>
</ul>
<p><strong><a href="/img/9.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/9.png"></a></strong></p>
<h4 id="3-1-2-lighthouse面板"><a href="#3-1-2-lighthouse面板" class="headerlink" title="3.1.2 lighthouse面板"></a>3.1.2 lighthouse面板</h4><ul>
<li>用于分析测试网页性能。</li>
</ul>
<p><a href="/img/10.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/10.png"></a></p>
<h4 id="3-1-3-network面板"><a href="#3-1-3-network面板" class="headerlink" title="3.1.3 network面板"></a>3.1.3 network面板</h4><ul>
<li>用于查看网页网络资源加载情况。</li>
</ul>
<p><a href="/img/11.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/11.png"></a></p>
<h4 id="3-1-4-性能数据分析面板（即将被移除）"><a href="#3-1-4-性能数据分析面板（即将被移除）" class="headerlink" title="3.1.4 性能数据分析面板（即将被移除）"></a>3.1.4 性能数据分析面板（即将被移除）</h4><ul>
<li>用于分析测试网页性能，但即将弃用。</li>
</ul>
<p><a href="/img/12.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/12.png"></a></p>
<p><strong>3.2 三方测评站点</strong></p>
<p>用于分析测试网页性能。</p>
<h4 id="3-2-1-pagespeed"><a href="#3-2-1-pagespeed" class="headerlink" title="3.2.1 pagespeed"></a>3.2.1 pagespeed</h4><p><a href="/img/13.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/13.png"></a></p>
<h4 id="3-2-2-webpagetest"><a href="#3-2-2-webpagetest" class="headerlink" title="3.2.2 webpagetest"></a>3.2.2 webpagetest</h4><p><a href="/img/14.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/14.png"></a></p>
<p><strong>3.3 webpack分析插件</strong></p>
<ul>
<li><p>Webpack Bundle Analyzer</p>
</li>
<li><p>用于分析 Webpack 构建输出的工具。它能够帮助开发者更好地理解构建产物（bundle）的组成，包括各个模块、库和资源文件的大小分布情况。</p>
</li>
<li><p>Source Map Explore</p>
</li>
<li><p>用于分析 JavaScript 源代码大小及其在打包后（如使用 Webpack 打包后的 bundle 文件）所占比例的工具。</p>
</li>
<li><p>umi，analyze&#x3D;1</p>
</li>
<li><p>umi内置分析产物构成体积分布方案。</p>
</li>
</ul>
<p><strong>3.4 VSCode 插件</strong></p>
<ul>
<li><p>Bundle Size</p>
</li>
<li><p>用于实时查看 Webpack 构建产物大小的插件。</p>
</li>
</ul>
<p><a href="/img/15.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/15.png"></a></p>
<p>四、总结</p>
<p>本文介绍了一些常见的性能优化策略以及用于调试优化效果的性能分析工具。我们在实际性能优化过程中，可以对自己要优化的目标项目进行分析，然后采用适合的策略去解决具体问题，最后用性能分析工具去验证优化效果。前端技术在持续发展，性能优化策略也会与时俱进。我们可以大胆尝试，小心求证。</p>
<p>路漫漫其修远兮，吾辈上下而求索.</p>
<p><strong>参考链接：</strong></p>
<p>[1]<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/umi-plugin-runtime-import">https://www.npmjs.com/package/umi-plugin-runtime-import</a></p>
<p>[2]<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/umi-plugin-runtime-import-v4">https://www.npmjs.com/package/umi-plugin-runtime-import-v4</a></p>
<p>[3]<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web/_Workers/_API/Using/_web/_workers">https://developer.mozilla.org/en-US/docs/Web/API/Web\_Workers\_API/Using\_web\_workers</a></p>
<p>[4]<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGPU/_API">https://developer.mozilla.org/en-US/docs/Web/API/WebGPU\_API</a></p>
<p>[5]<a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react/useMemo">https://zh-hans.react.dev/reference/react/useMemo</a></p>
<p>[6]<a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react/useCallback">https://zh-hans.react.dev/reference/react/useCallback</a></p>
<p>[7]<a target="_blank" rel="noopener" href="https://ahooks.js.org/zh-CN/hooks/use-request/cache#swr">https://ahooks.js.org/zh-CN/hooks/use-request/cache#swr</a></p>
<p>[8]<a target="_blank" rel="noopener" href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/utils/cache.ts">https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/utils/cache.ts</a></p>
<p>[9]<a target="_blank" rel="noopener" href="https://github.com/umijs/qiankun/issues/1555">https://github.com/umijs/qiankun/issues/1555</a></p>
<p>[10]<a target="_blank" rel="noopener" href="https://www.yuque.com/kuitos/gky7yw/gs4okg">https://www.yuque.com/kuitos/gky7yw/gs4okg</a></p>
<p>[11]<a target="_blank" rel="noopener" href="https://css-tricks.com/css-sprites/">https://css-tricks.com/css-sprites/</a></p>
<p>[12]<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position</a></p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-10-11</span>
            
                <span>该篇文章被 Jiang Jiang</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85/'>
                            阿里云开发者
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85/'>
                            阿里云开发者
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2024/10/12/coderwhy-JavaScript%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/'>coderwhy-JavaScript高级系列</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2024/10/11/iframe%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8/">iframe的嵌套使用</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>宇宙里有什么不是暂时</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>